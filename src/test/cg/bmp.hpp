// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <memory>
enum class BMPCompression : std::uint32_t {
    RGB = 0,
    RLE8 = 1,
    RLE4 = 2,
    BIT_FIELDS = 3,
    JPEG = 4,
    PNG = 5,
};
constexpr auto BMP_MAGIC_NUMBER = 0x4d42;
struct LineState {
    std::uint32_t width = 0;
    std::uint32_t bitSize = 0;
};
struct BMPFileHeader;
struct BMPInfoHeader;
struct RGB;
struct SingleLine;
struct ColorTableEntry;
struct BMPHeader;
struct BMP;
struct BMPFileHeader {
    std::uint16_t bfType = 0;
    std::uint32_t bfSize = 0;
    std::uint16_t bfReserved1 = 0;
    std::uint16_t bfReserved2 = 0;
    std::uint32_t bfOffBits = 0;
    bool encode(::futils::binary::writer& w) const;
    bool decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 14;
};
struct BMPInfoHeader {
    std::uint32_t biSize = 0;
    std::int32_t biWidth = 0;
    std::int32_t biHeight = 0;
    std::uint16_t biPlanes = 0;
    std::uint16_t biBitCount = 0;
    BMPCompression biCompression{};
    std::uint32_t biSizeImage = 0;
    std::int32_t biXPelsPerMeter = 0;
    std::int32_t biYPelsPerMeter = 0;
    std::uint32_t biClrUsed = 0;
    std::uint32_t biClrImportant = 0;
    bool encode(::futils::binary::writer& w) const;
    bool decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 40;
};
struct RGB {
    std::uint8_t b = 0;
    std::uint8_t g = 0;
    std::uint8_t r = 0;
    bool encode(::futils::binary::writer& w) const;
    bool decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 3;
};
struct SingleLine {
    ::futils::view::rvec data;
    bool set_data(auto&& v) {
        (*this).data = std::forward<decltype(v)>(v);
        return true;
    }
    bool encode(::futils::binary::writer& w, LineState& line_state) const;
    bool decode(::futils::binary::reader& r, LineState& line_state);
};
struct ColorTableEntry {
    RGB rgb;
    std::uint8_t reserved = 0;
    bool encode(::futils::binary::writer& w) const;
    bool decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 4;
};
struct BMPHeader {
    BMPFileHeader file_header;
    BMPInfoHeader info_header;
    bool encode(::futils::binary::writer& w) const;
    bool decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 54;
};
struct BMP {
    BMPHeader header;
    ::futils::view::rvec data;
    bool encode(::futils::binary::writer& w) const;
    bool decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 54;
};
inline bool BMPFileHeader::encode(::futils::binary::writer& w) const {
    if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).bfType), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).bfSize), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).bfReserved1), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).bfReserved2), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).bfOffBits), false)) {
        return false;
    }
    return true;
}
inline bool BMPFileHeader::decode(::futils::binary::reader& r) {
    if (!::futils::binary::read_num(r, (*this).bfType, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).bfSize, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).bfReserved1, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).bfReserved2, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).bfOffBits, false)) {
        return false;
    }
    return true;
}
inline bool BMPInfoHeader::encode(::futils::binary::writer& w) const {
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).biSize), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::int32_t>((*this).biWidth), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::int32_t>((*this).biHeight), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).biPlanes), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).biBitCount), false)) {
        return false;
    }
    auto tmp_0_ = static_cast<std::uint32_t>((*this).biCompression);
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(tmp_0_), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).biSizeImage), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::int32_t>((*this).biXPelsPerMeter), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::int32_t>((*this).biYPelsPerMeter), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).biClrUsed), false)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).biClrImportant), false)) {
        return false;
    }
    return true;
}
inline bool BMPInfoHeader::decode(::futils::binary::reader& r) {
    if (!::futils::binary::read_num(r, (*this).biSize, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biWidth, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biHeight, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biPlanes, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biBitCount, false)) {
        return false;
    }
    std::uint32_t tmp_1_ = 0;
    if (!::futils::binary::read_num(r, tmp_1_, false)) {
        return false;
    }
    (*this).biCompression = static_cast<BMPCompression>(tmp_1_);
    if (!::futils::binary::read_num(r, (*this).biSizeImage, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biXPelsPerMeter, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biYPelsPerMeter, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biClrUsed, false)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).biClrImportant, false)) {
        return false;
    }
    return true;
}
inline bool RGB::encode(::futils::binary::writer& w) const {
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).b), true)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).g), true)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).r), true)) {
        return false;
    }
    return true;
}
inline bool RGB::decode(::futils::binary::reader& r) {
    if (!::futils::binary::read_num(r, (*this).b, true)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).g, true)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).r, true)) {
        return false;
    }
    return true;
}
inline bool SingleLine::encode(::futils::binary::writer& w, LineState& line_state) const {
    auto inByte = (line_state.width * line_state.bitSize) / 8;
    auto len = inByte + (((4 - (inByte % 4))) % 4);
    auto tmp_2_ = len;
    if (tmp_2_ != (*this).data.size()) {
        return false;
    }
    if (!w.write((*this).data)) {
        return false;
    }
    return true;
}
inline bool SingleLine::decode(::futils::binary::reader& r, LineState& line_state) {
    auto inByte = (line_state.width * line_state.bitSize) / 8;
    auto len = inByte + (((4 - (inByte % 4))) % 4);
    auto tmp_3_ = len;
    if (!r.read((*this).data, tmp_3_)) {
        return false;
    }
    return true;
}
inline bool ColorTableEntry::encode(::futils::binary::writer& w) const {
    if (!(*this).rgb.encode(w)) {
        return false;
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).reserved), true)) {
        return false;
    }
    return true;
}
inline bool ColorTableEntry::decode(::futils::binary::reader& r) {
    if (!(*this).rgb.decode(r)) {
        return false;
    }
    if (!::futils::binary::read_num(r, (*this).reserved, true)) {
        return false;
    }
    return true;
}
inline bool BMPHeader::encode(::futils::binary::writer& w) const {
    if (!(*this).file_header.encode(w)) {
        return false;
    }
    if (!(*this).info_header.encode(w)) {
        return false;
    }
    return true;
}
inline bool BMPHeader::decode(::futils::binary::reader& r) {
    if (!(*this).file_header.decode(r)) {
        return false;
    }
    if (!(*this).info_header.decode(r)) {
        return false;
    }
    return true;
}
inline bool BMP::encode(::futils::binary::writer& w) const {
    if (!(*this).header.encode(w)) {
        return false;
    }
    auto tmp_4_ = (*this).header.info_header.biSizeImage;
    if (tmp_4_ != (*this).data.size()) {
        return false;
    }
    if (!w.write((*this).data)) {
        return false;
    }
    return true;
}
inline bool BMP::decode(::futils::binary::reader& r) {
    if (!(*this).header.decode(r)) {
        return false;
    }
    auto tmp_5_ = (*this).header.info_header.biSizeImage;
    if (!r.read((*this).data, tmp_5_)) {
        return false;
    }
    return true;
}
