// generated by pscmpl (https://github.com/on-keyday/utils)
#include <string>

template <class Input, class Output>
bool SPACE(Input&& input, Output& output);

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output);

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output);

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output);

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output);

template <class Input, class Output>
bool EXPR(Input&& input, Output& output);

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output);

template <class Input, class Output>
bool SPACE(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8" ") || input.expect(u8"\t"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"if") || input.expect(u8"else") || input.expect(u8"for"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{") || input.copy().expect(u8";"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output) {
    // ensure requirement
    if (!(KEYWORD(input.copy(), output))) {
        return false;
    }

    // consume tokens
    if (!(((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_0_sXloUwxz9YVlxWyqro7y = input.pos();
    while (((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false) || ((input.current() >= '0' && input.current() <= '9') ? input.read(1) : false)) {
        tmpvar_0_sXloUwxz9YVlxWyqro7y = input.pos();  // update index
    }
    input.set_pos(tmpvar_0_sXloUwxz9YVlxWyqro7y);

    return true;
}

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"struct"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_1_NTCCsfiERixXJWNkwO1f = input.pos();
    while (SPACE(input, output)) {
        tmpvar_1_NTCCsfiERixXJWNkwO1f = input.pos();  // update index
    }
    input.set_pos(tmpvar_1_NTCCsfiERixXJWNkwO1f);

    // define variable
    auto name = std::string();

    // bind to variable
    auto tmpvar_2_GhpvKN0duiOqI2tt11Hg = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_2_GhpvKN0duiOqI2tt11Hg, name)) {
        return false;
    }

    // consume tokens
    if (!(input.expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_3_j4YK0fgLIPTVdkyJb27j = input.pos();
    while (MEMBER(input, output)) {
        tmpvar_3_j4YK0fgLIPTVdkyJb27j = input.pos();  // update index
    }
    input.set_pos(tmpvar_3_j4YK0fgLIPTVdkyJb27j);

    // consume tokens
    if (!(input.expect(u8"}"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output) {
    // define variable
    auto name = std::string();

    // bind to variable
    auto tmpvar_4_G5McKU0kwzO2NJi1Foix = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_4_G5McKU0kwzO2NJi1Foix, name)) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EXPR(Input&& input, Output& output) {
    // define variable
    auto A = std::string();

    // consume tokens
    if (!([&input, &output] {
            // consume tokens while condition is true
            size_t tmpvar_5_1pgsbrrzzII9dHoGTTfI = input.pos();
            while (input.expect(u8"+") || input.expect(u8"*") || input.expect(u8"-")) {
                tmpvar_5_1pgsbrrzzII9dHoGTTfI = input.pos();  // update index
            }
            input.set_pos(tmpvar_5_1pgsbrrzzII9dHoGTTfI);

            // consume tokens
            if (!(VARNAME(input, output))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_6_BoWwmBAcqXDzgF9fsl6p = input.pos();
    while (input.expect(u8"+") && VARNAME(input, output)) {
        tmpvar_6_BoWwmBAcqXDzgF9fsl6p = input.pos();  // update index
    }
    input.set_pos(tmpvar_6_BoWwmBAcqXDzgF9fsl6p);

    // consume tokens
    if (!(input.read(1 + 83) || input.expect(u8"AAA") || input.read((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) / (1 + 2 + 3 * 4 + 5 + 6 + 7 + 8 + 9)))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output) {
    // consume tokens
    if (!(STRUCT(input, output))) {
        return false;
    }

    return true;
}

#include <file/file_view.h>
#include <core/sequencer.h>

template <class T>
struct Input {
    utils::Sequencer<utils::buffer_t<T&>> seq;
    Input(T& t)
        : seq(t) {}

    Input(T& t, size_t pos)
        : seq(t) {
        seq.rptr = pos;
    }

    size_t pos() const {
        return seq.rptr;
    }

    void set_pos(size_t pos) {
        seq.rptr = pos;
    }

    Input copy() {
        return Input{seq.buf.buffer, seq.rptr};
    }

    bool expect(auto&& value) {
        return seq.seek_if(value);
    }

    bool read(size_t value) {
        return seq.consume(value);
    }

    bool bind(size_t start, auto& tobind) {
        return bind_object(*this, start, tobind);
    }

    auto current() {
        return seq.current();
    }
};

struct Output {};

int main(int argc, char** argv) {
    utils::file::View view;
    if (!view.open(argv[1])) {
        return -1;
    }
    Output v;
    auto input = Input{view};
    return EntryPoint(input, v) ? 0 : 1;
}
