// generated by pscmpl (https://github.com/on-keyday/utils)

template <class Input, class Output>
bool SPACE(Input&& input, Output& output);

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output);

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output);

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output);

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output);

template <class Input, class Output>
bool EXPR(Input&& input, Output& output);

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output);

template <class Input, class Output>
bool SPACE(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8" ") || input.expect(u8"\t"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"if") || input.expect(u8"else") || input.expect(u8"for"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{") || input.copy().expect(u8";"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output) {
    // ensure requirement
    if (!(KEYWORD(input.copy(), output))) {
        return false;
    }

    // consume tokens
    if (!(((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_0_s3ucr7MIhkK3ezBKFvcT = input.pos();
    while (((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false) || ((input.current() >= '0' && input.current() <= '9') ? input.read(1) : false)) {
        tmpvar_0_s3ucr7MIhkK3ezBKFvcT = input.pos();  // update index
    }
    input.set_pos(tmpvar_0_s3ucr7MIhkK3ezBKFvcT);
    return true;
}

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"struct"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_1_p5OCNmnV1pPoCBsLn7OE = input.pos();
    while (SPACE(input, output)) {
        tmpvar_1_p5OCNmnV1pPoCBsLn7OE = input.pos();  // update index
    }
    input.set_pos(tmpvar_1_p5OCNmnV1pPoCBsLn7OE);
    // consume tokens
    if (!(input.expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_2_NtBFlBklToF65p6PeoXX = input.pos();
    while (MEMBER(input, output)) {
        tmpvar_2_NtBFlBklToF65p6PeoXX = input.pos();  // update index
    }
    input.set_pos(tmpvar_2_NtBFlBklToF65p6PeoXX);
    // consume tokens
    if (!(input.expect(u8"}"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output) {
    return true;
}

template <class Input, class Output>
bool EXPR(Input&& input, Output& output) {
    // consume tokens
    if (!([&input, &output] {
            // consume tokens while condition is true
            size_t tmpvar_3_JWiXAz84TJeXnyYpyicD = input.pos();
            while (input.expect(u8"+") || input.expect(u8"*") || input.expect(u8"-")) {
                tmpvar_3_JWiXAz84TJeXnyYpyicD = input.pos();  // update index
            }
            input.set_pos(tmpvar_3_JWiXAz84TJeXnyYpyicD);
            // consume tokens
            if (!(VARNAME(input, output))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_4_f0FmFqK6M2OLgXpzqxRJ = input.pos();
    while (input.expect(u8"+") && VARNAME(input, output)) {
        tmpvar_4_f0FmFqK6M2OLgXpzqxRJ = input.pos();  // update index
    }
    input.set_pos(tmpvar_4_f0FmFqK6M2OLgXpzqxRJ);
    return true;
}

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output) {
    // consume tokens
    if (!(STRUCT(input, output))) {
        return false;
    }

    return true;
}

#include <file/file_view.h>
#include <core/sequencer.h>

template <class T>
struct Input {
    utils::Sequencer<utils::buffer_t<T>> seq;
    Input(T& t)
        : seq(t) {}

    Input(T& t, size_t pos)
        : seq(t) {
        seq.rptr = pos;
    }

    void pos() const {
        return seq.rptr;
    }

    void set_pos(size_t pos) {
        seq.rptr = pos;
    }

    Input copy() {
        return Input{seq.buf.buffer, seq.rptr};
    }

    bool expect(auto&& value) {
        return seq.seek_if(value);
    }

    auto current() {
        return seq.current();
    }
};

struct Output {};

int main(int argc, char** argv) {
    utils::file::View view;
    if (!view.open(argv[1])) {
        return -1;
    }
    Output v;
    auto input = Input{view};
    // return EntryPoint(input, v) ? 0 : 1;
}
