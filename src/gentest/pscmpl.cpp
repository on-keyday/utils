// generated by pscmpl (https://github.com/on-keyday/utils)
#include <string>

template <class Input, class Output>
bool SPACE(Input&& input, Output& output);

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output);

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output);

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output);

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output);

template <class Input, class Output>
bool EXPR(Input&& input, Output& output);

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output);

template <class Input, class Output>
bool FRAME(Input&& input, Output& output);

template <class Input, class Output>
bool SPACE(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8" ") || input.expect(u8"\t"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"if") || input.expect(u8"else") || input.expect(u8"for"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{") || input.copy().expect(u8";"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output) {
    // ensure requirement
    if (!(KEYWORD(input.copy(), output))) {
        return false;
    }

    // consume tokens
    if (!(((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_0_qhkPyZg564f8AkkfDsLu = input.pos();
    while (((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false) || ((input.current() >= '0' && input.current() <= '9') ? input.read(1) : false)) {
        tmpvar_0_qhkPyZg564f8AkkfDsLu = input.pos();  // update index
    }
    input.set_pos(tmpvar_0_qhkPyZg564f8AkkfDsLu);

    return true;
}

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"struct"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_1_XTIoQVu7DrskReqOMAv6 = input.pos();
    while (SPACE(input, output)) {
        tmpvar_1_XTIoQVu7DrskReqOMAv6 = input.pos();  // update index
    }
    input.set_pos(tmpvar_1_XTIoQVu7DrskReqOMAv6);

    // define variable
    auto name = std::string();

    // bind to variable
    auto tmpvar_2_fpiUnH91VSnkhbnT7kg9 = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_2_fpiUnH91VSnkhbnT7kg9, name)) {
        return false;
    }

    // consume tokens
    if (!(input.expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_3_JkzkCzH2Fk89z9mCN3kV = input.pos();
    while (MEMBER(input, output)) {
        tmpvar_3_JkzkCzH2Fk89z9mCN3kV = input.pos();  // update index
    }
    input.set_pos(tmpvar_3_JkzkCzH2Fk89z9mCN3kV);

    // consume tokens
    if (!(input.expect(u8"}"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output) {
    // define variable
    auto name = std::string();

    // bind to variable
    auto tmpvar_4_McsgtKV5AerRBWlSITEk = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_4_McsgtKV5AerRBWlSITEk, name)) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EXPR(Input&& input, Output& output) {
    // define variable
    auto A = std::string();

    // consume tokens
    if (!([&input, &output] {
            // consume tokens while condition is true
            size_t tmpvar_5_GjmoepQ1ichn8iyj3igp = input.pos();
            while (input.expect(u8"+") || input.expect(u8"*") || input.expect(u8"-")) {
                tmpvar_5_GjmoepQ1ichn8iyj3igp = input.pos();  // update index
            }
            input.set_pos(tmpvar_5_GjmoepQ1ichn8iyj3igp);

            // consume tokens
            if (!(VARNAME(input, output))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_6_ccho0mfM8ES2GZim034J = input.pos();
    while (input.expect(u8"+") && VARNAME(input, output)) {
        tmpvar_6_ccho0mfM8ES2GZim034J = input.pos();  // update index
    }
    input.set_pos(tmpvar_6_ccho0mfM8ES2GZim034J);

    // consume tokens
    if (!(input.read(1 + 83) || input.expect(u8"AAA") || input.read((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) / (1 + 2 + 3 * 4 + 5 + 6 + 7 + 8 + 9)))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output) {
    // consume tokens
    if (!(STRUCT(input, output))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool FRAME(Input&& input, Output& output) {
    // bind to variable
    auto tmpvar_7_ObKf2rHAnUXphD45ltdc = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(3))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_7_ObKf2rHAnUXphD45ltdc, output.len)) {
        return false;
    }

    // bind to variable
    auto tmpvar_8_bdrUBrq2MJe3vGZ6PfBT = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(1))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_8_bdrUBrq2MJe3vGZ6PfBT, output.type)) {
        return false;
    }

    // bind to variable
    auto tmpvar_9_qhUXU94YVJpHREWxDWzw = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(1))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_9_qhUXU94YVJpHREWxDWzw, output.flag)) {
        return false;
    }

    // bind to variable
    auto tmpvar_10_Nz0N6DI4XVJ6Fttw9NPM = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(4))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_10_Nz0N6DI4XVJ6Fttw9NPM, output.id)) {
        return false;
    }

    // if statement
    if (output.type == 0) {
    }
    return true;
}

#include <file/file_view.h>
#include <core/sequencer.h>

template <class T>
struct Input {
    utils::Sequencer<utils::buffer_t<T&>> seq;
    Input(T& t)
        : seq(t) {}

    Input(T& t, size_t pos)
        : seq(t) {
        seq.rptr = pos;
    }

    size_t pos() const {
        return seq.rptr;
    }

    void set_pos(size_t pos) {
        seq.rptr = pos;
    }

    Input copy() {
        return Input{seq.buf.buffer, seq.rptr};
    }

    bool expect(auto&& value) {
        return seq.seek_if(value);
    }

    bool read(size_t value) {
        return seq.consume(value);
    }

    bool bind(size_t start, auto& tobind) {
        return true;
        // return bind_object(*this, start, tobind);
    }

    auto current() {
        return seq.current();
    }
};

struct Output {
    int len;
    int type;
    int flag;
    int id;
};

int main(int argc, char** argv) {
    utils::file::View view;
    if (!view.open(argv[1])) {
        return -1;
    }
    Output v;
    auto input = Input{view};
    return EntryPoint(input, v) ? 0 : 1;
}
