// generated by pscmpl (https://github.com/on-keyday/utils)
#include <string>

template <class Input, class Output>
bool SPACE(Input&& input, Output& output);

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output);

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output);

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output);

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output);

template <class Input, class Output>
bool EXPR(Input&& input, Output& output);

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output);

template <class Input, class Output>
bool FRAME(Input&& input, Output& output);

template <class Input, class Output>
bool SPACE(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8" ") || input.expect(u8"\t"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"if") || input.expect(u8"else") || input.expect(u8"for"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{") || input.copy().expect(u8";"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output) {
    // ensure requirement
    if (!(KEYWORD(input.copy(), output))) {
        return false;
    }

    // consume tokens
    if (!(((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_0_slrQ6dRChNjGBQ32iX9L = input.pos();
    while (((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false) || ((input.current() >= '0' && input.current() <= '9') ? input.read(1) : false)) {
        tmpvar_0_slrQ6dRChNjGBQ32iX9L = input.pos();  // update index
    }
    input.set_pos(tmpvar_0_slrQ6dRChNjGBQ32iX9L);

    return true;
}

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"struct"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_1_2Syap6ThL6oVLA2XNWOc = input.pos();
    while (SPACE(input, output)) {
        tmpvar_1_2Syap6ThL6oVLA2XNWOc = input.pos();  // update index
    }
    input.set_pos(tmpvar_1_2Syap6ThL6oVLA2XNWOc);

    // define variable
    auto name = std::string();

    // bind to variable
    auto tmpvar_2_jVSuml5xfaA4JmVpg4nA = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_2_jVSuml5xfaA4JmVpg4nA, name)) {
        return false;
    }

    // consume tokens
    if (!(input.expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_3_kF6rzl5BbLXQtYWDAbn7 = input.pos();
    while (MEMBER(input, output)) {
        tmpvar_3_kF6rzl5BbLXQtYWDAbn7 = input.pos();  // update index
    }
    input.set_pos(tmpvar_3_kF6rzl5BbLXQtYWDAbn7);

    // consume tokens
    if (!(input.expect(u8"}"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output) {
    // define variable
    auto name = std::string();

    // bind to variable
    auto tmpvar_4_gxUj8baas3cx4zle5AML = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_4_gxUj8baas3cx4zle5AML, name)) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EXPR(Input&& input, Output& output) {
    // define variable
    auto A = std::string();

    // consume tokens
    if (!([&input, &output] {
            // consume tokens while condition is true
            size_t tmpvar_5_t7y9AqvfywZNUeijlblr = input.pos();
            while (input.expect(u8"+") || input.expect(u8"*") || input.expect(u8"-")) {
                tmpvar_5_t7y9AqvfywZNUeijlblr = input.pos();  // update index
            }
            input.set_pos(tmpvar_5_t7y9AqvfywZNUeijlblr);

            // consume tokens
            if (!(VARNAME(input, output))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_6_DrXqWYVEXb22MyaktXa0 = input.pos();
    while (input.expect(u8"+") && VARNAME(input, output)) {
        tmpvar_6_DrXqWYVEXb22MyaktXa0 = input.pos();  // update index
    }
    input.set_pos(tmpvar_6_DrXqWYVEXb22MyaktXa0);

    // consume tokens
    if (!(input.read(1 + 83) || input.expect(u8"AAA") || input.read((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) / (1 + 2 + 3 * 4 + 5 + 6 + 7 + 8 + 9)))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output) {
    // consume tokens
    if (!(STRUCT(input, output))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool FRAME(Input&& input, Output& output) {
    // bind to variable
    auto tmpvar_7_6MaxThYtUQpvOFdQQQxu = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(3))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_7_6MaxThYtUQpvOFdQQQxu, output.len)) {
        return false;
    }

    // bind to variable
    auto tmpvar_8_p1QklNicSsPKFDIZJkqS = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(1))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_8_p1QklNicSsPKFDIZJkqS, output.type)) {
        return false;
    }

    // bind to variable
    auto tmpvar_9_hsgxffM6c1mkNUokWjob = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(1))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_9_hsgxffM6c1mkNUokWjob, output.flag)) {
        return false;
    }

    // bind to variable
    auto tmpvar_10_GrZ3b0CgwnOLDSvZ4cV2 = input.pos();
    if (!([&input, &output] {
            // consume tokens
            if (!(input.read(4))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }
    if (!input.bind(tmpvar_10_GrZ3b0CgwnOLDSvZ4cV2, output.id)) {
        return false;
    }

    // if statement
    if (output.object == 0) {
    }
    return true;
}

#include <file/file_view.h>
#include <core/sequencer.h>

template <class T>
struct Input {
    utils::Sequencer<utils::buffer_t<T&>> seq;
    Input(T& t)
        : seq(t) {}

    Input(T& t, size_t pos)
        : seq(t) {
        seq.rptr = pos;
    }

    size_t pos() const {
        return seq.rptr;
    }

    void set_pos(size_t pos) {
        seq.rptr = pos;
    }

    Input copy() {
        return Input{seq.buf.buffer, seq.rptr};
    }

    bool expect(auto&& value) {
        return seq.seek_if(value);
    }

    bool read(size_t value) {
        return seq.consume(value);
    }

    bool bind(size_t start, auto& tobind) {
        return true;  //    return bind_object(*this,start,tobind);
    }

    auto current() {
        return seq.current();
    }
};

struct Output {};

int main(int argc, char** argv) {
    utils::file::View view;
    if (!view.open(argv[1])) {
        return -1;
    }
    Output v;
    auto input = Input{view};
    return EntryPoint(input, v) ? 0 : 1;
}
