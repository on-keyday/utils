// generated by pscmpl (https://github.com/on-keyday/utils)

template <class Input, class Output>
bool SPACE(Input&& input, Output& output);

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output);

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output);

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output);

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output);

template <class Input, class Output>
bool EXPR(Input&& input, Output& output);

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output);

template <class Input, class Output>
bool SPACE(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8" ") || input.expect(u8"\t"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool KEYWORD(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"if") || input.expect(u8"else") || input.expect(u8"for"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{") || input.copy().expect(u8";"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool VARNAME(Input&& input, Output& output) {
    // ensure requirement
    if (!(KEYWORD(input.copy(), output))) {
        return false;
    }

    // consume tokens
    if (!(((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_0_caAGFAQ3Be2oyMLIy0pd = input.pos();
    while (((input.current() >= 'a' && input.current() <= 'z') ? input.read(1) : false) || ((input.current() >= 'A' && input.current() <= 'Z') ? input.read(1) : false) || ((input.current() >= '0' && input.current() <= '9') ? input.read(1) : false)) {
        tmpvar_0_caAGFAQ3Be2oyMLIy0pd = input.pos();  // update index
    }
    input.set_pos(tmpvar_0_caAGFAQ3Be2oyMLIy0pd);

    return true;
}

template <class Input, class Output>
bool STRUCT(Input&& input, Output& output) {
    // consume tokens
    if (!(input.expect(u8"struct"))) {
        return false;
    }

    // ensure requirement
    if (!(SPACE(input.copy(), output) || input.copy().expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_1_W1GNKeNoqCheZom39Bzt = input.pos();
    while (SPACE(input, output)) {
        tmpvar_1_W1GNKeNoqCheZom39Bzt = input.pos();  // update index
    }
    input.set_pos(tmpvar_1_W1GNKeNoqCheZom39Bzt);

    // consume tokens
    if (!(input.expect(u8"{"))) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_2_K1AaC7cxjTyKkbtn3wPO = input.pos();
    while (MEMBER(input, output)) {
        tmpvar_2_K1AaC7cxjTyKkbtn3wPO = input.pos();  // update index
    }
    input.set_pos(tmpvar_2_K1AaC7cxjTyKkbtn3wPO);

    // consume tokens
    if (!(input.expect(u8"}"))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool MEMBER(Input&& input, Output& output) {
    // define variable
    auto index = 0;

    // bind to variable
    auto tmpvar_3_8Jc7uyVvmZBkgnbDkV9L = input.pos();
    if (!(VARNAME(input, output))) {
        return false;
    }
    if (!input.bind(tmpvar_3_8Jc7uyVvmZBkgnbDkV9L, output.member[index].name)) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EXPR(Input&& input, Output& output) {
    // define variable
    auto A = std::string();

    // consume tokens
    if (!([&input, &output] {
            // consume tokens while condition is true
            size_t tmpvar_4_ul1n42ZkiHae6iNHGsX8 = input.pos();
            while (input.expect(u8"+") || input.expect(u8"*") || input.expect(u8"-")) {
                tmpvar_4_ul1n42ZkiHae6iNHGsX8 = input.pos();  // update index
            }
            input.set_pos(tmpvar_4_ul1n42ZkiHae6iNHGsX8);

            // consume tokens
            if (!(VARNAME(input, output))) {
                return false;
            }

            return true;
        }())) {
        return false;
    }

    // consume tokens while condition is true
    size_t tmpvar_5_gCyp4w6nag9DmM4vcOdZ = input.pos();
    while (input.expect(u8"+") && VARNAME(input, output)) {
        tmpvar_5_gCyp4w6nag9DmM4vcOdZ = input.pos();  // update index
    }
    input.set_pos(tmpvar_5_gCyp4w6nag9DmM4vcOdZ);

    // consume tokens
    if (!(input.read(1 + 83) || input.expect(u8"AAA") || input.read((1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9) / (1 + 2 + 3 * 4 + 5 + 6 + 7 + 8 + 9)))) {
        return false;
    }

    return true;
}

template <class Input, class Output>
bool EntryPoint(Input&& input, Output& output) {
    // consume tokens
    if (!(STRUCT(input, output))) {
        return false;
    }

    return true;
}

#include <file/file_view.h>
#include <core/sequencer.h>

template <class T>
struct Input {
    utils::Sequencer<utils::buffer_t<T>> seq;
    Input(T& t)
        : seq(t) {}

    Input(T& t, size_t pos)
        : seq(t) {
        seq.rptr = pos;
    }

    size_t pos() const {
        return seq.rptr;
    }

    void set_pos(size_t pos) {
        seq.rptr = pos;
    }

    Input copy() {
        return Input{seq.buf.buffer, seq.rptr};
    }

    bool expect(auto&& value) {
        return seq.seek_if(value);
    }

    bool read(size_t v) {
        return seq.consume(v);
    }

    auto current() {
        return seq.current();
    }

    bool bind(size_t start, auto& v) {
        return v;
    }
};

struct Tmp {
    int name;
};

struct Output {
    Tmp member[2];
};

int main(int argc, char** argv) {
    utils::file::View view;
    if (!view.open(argv[1])) {
        return -1;
    }
    Output v;
    auto input = Input{view};
    return EntryPoint(input, v) ? 0 : 1;
}
