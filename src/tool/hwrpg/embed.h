// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
namespace embed {
    struct ConsistentData {
        std::uint64_t files_len = 0;
        std::uint64_t offset = 0;
        std::array<std::uint8_t, 32> hash;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 48;
    };
    inline ::futils::error::Error<> ConsistentData::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).files_len), true)) {
            return ::futils::error::Error<>("encode: ConsistentData::files_len: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).offset), true)) {
            return ::futils::error::Error<>("encode: ConsistentData::offset: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        if (!w.write((*this).hash)) {
            return ::futils::error::Error<>("encode: ConsistentData::hash: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> ConsistentData::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).files_len, true)) {
            return ::futils::error::Error<>("decode: ConsistentData::files_len: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).offset, true)) {
            return ::futils::error::Error<>("decode: ConsistentData::offset: read int failed", ::futils::error::Category::lib);
        }
        if (!r.read((*this).hash)) {
            return ::futils::error::Error<>("decode: ConsistentData::hash: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct Varint {
        ::futils::binary::flags_t<std::uint64_t, 2, 62> flags_1_;
        bits_flag_alias_method(flags_1_, 0, prefix);
        bits_flag_alias_method(flags_1_, 1, value);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 0;
    };
    inline ::futils::error::Error<> Varint::encode(::futils::binary::writer& w) const {
        if ((*this).prefix() == 0) {
            std::uint8_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint8_t(0) << 6;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        else if ((*this).prefix() == 1) {
            std::uint16_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint16_t(1) << 14;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        else if ((*this).prefix() == 2) {
            std::uint32_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint32_t(2) << 30;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        else if ((*this).prefix() == 3) {
            std::uint64_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint64_t(3) << 62;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Varint::decode(::futils::binary::reader& r) {
        if (!r.load_stream(1)) {
            return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
        }
        std::uint8_t tmp3 = (r.top() >> 6) & 0x3;
        (*this).prefix(tmp3);
        if ((*this).prefix() == 0) {
            std::uint8_t tmp4 = 0;
            if (!::futils::binary::read_num(r, tmp4, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp4 &= ~(std::uint8_t(0x3) << 6);
            (*this).value(tmp4);
        }
        else if ((*this).prefix() == 1) {
            std::uint16_t tmp5 = 0;
            if (!::futils::binary::read_num(r, tmp5, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp5 &= ~(std::uint16_t(0x3) << 14);
            (*this).value(tmp5);
        }
        else if ((*this).prefix() == 2) {
            std::uint32_t tmp6 = 0;
            if (!::futils::binary::read_num(r, tmp6, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp6 &= ~(std::uint32_t(0x3) << 30);
            (*this).value(tmp6);
        }
        else if ((*this).prefix() == 3) {
            std::uint64_t tmp7 = 0;
            if (!::futils::binary::read_num(r, tmp7, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp7 &= ~(std::uint64_t(0x3) << 62);
            (*this).value(tmp7);
        }
        return ::futils::error::Error<>();
    }
    struct EmbedFS {
        //"HWIDAT" (6 bytes)
        ::futils::view::rvec data;
        ConsistentData consistent_data;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 6;
    };
    inline ::futils::error::Error<> EmbedFS::encode(::futils::binary::writer& w) const {
        if (!w.write(::futils::view::rvec("HWIDAT", 6))) {
            return ::futils::error::Error<>("encode: EmbedFS::magic: write string failed; \"HWIDAT\"", ::futils::error::Category::lib);
        }
        if (!w.write((*this).data)) {
            return ::futils::error::Error<>("encode: EmbedFS::data: write array failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).consistent_data.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> EmbedFS::decode(::futils::binary::reader& r) {
        ::futils::view::rvec tmp_8_ = {};
        if (!r.read_direct(tmp_8_, 6)) {
            return ::futils::error::Error<>("decode: EmbedFS::magic: read string failed", ::futils::error::Category::lib);
        }
        if (tmp_8_ != ::futils::view::rvec("HWIDAT", 6)) {
            return ::futils::error::Error<>("decode: EmbedFS::magic: read string failed; not match to \"HWIDAT\"", ::futils::error::Category::lib);
        }
        if (r.is_stream()) {
            return ::futils::error::Error<>("decode: EmbedFS::data: read array failed; stream mode is currently not supported for fixed terminator", ::futils::error::Category::lib);
        }
        if (r.remain().size() < 48) {
            return ::futils::error::Error<>("decode: EmbedFS::data: remain size is not enough; require 48", ::futils::error::Category::lib);
        }
        if (!r.read((*this).data, (r.remain().size() - 48))) {
            return ::futils::error::Error<>("decode: EmbedFS::data: read byte array failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).consistent_data.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct Name {
        Varint len;
        ::futils::view::rvec name;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> Name::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).len.encode(w)) {
            return err;
        }
        auto tmp_9_ = (*this).len.value();
        if (tmp_9_ != (*this).name.size()) {
            return ::futils::error::Error<>("encode: Name::name: dynamic length is not compatible with its length; tmp_9_!=(*this).name.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).name)) {
            return ::futils::error::Error<>("encode: Name::name: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Name::decode(::futils::binary::reader& r) {
        if (auto err = (*this).len.decode(r)) {
            return err;
        }
        auto tmp_10_ = (*this).len.value();
        if (!r.read((*this).name, tmp_10_)) {
            return ::futils::error::Error<>("decode: Name::name: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct EmbedFileIndex {
        Name name;
        Varint len;
        Varint offset;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> EmbedFileIndex::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        if (auto err = (*this).len.encode(w)) {
            return err;
        }
        if (auto err = (*this).offset.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> EmbedFileIndex::decode(::futils::binary::reader& r) {
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        if (auto err = (*this).len.decode(r)) {
            return err;
        }
        if (auto err = (*this).offset.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct EmbedIndexFile {
        //"HWIDX" (5 bytes)
        std::vector<EmbedFileIndex> files;
        ConsistentData consistent_data;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 5;
    };
    inline ::futils::error::Error<> EmbedIndexFile::encode(::futils::binary::writer& w) const {
        if (!w.write(::futils::view::rvec("HWIDX", 5))) {
            return ::futils::error::Error<>("encode: EmbedIndexFile::magic: write string failed; \"HWIDX\"", ::futils::error::Category::lib);
        }
        for (auto& tmp_11_ : (*this).files) {
            if (auto err = tmp_11_.encode(w)) {
                return err;
            }
        }
        if (auto err = (*this).consistent_data.encode(w)) {
            return err;
        }
        if (!((*this).files.size() == (*this).consistent_data.files_len)) {
            return ::futils::error::Error<>("encode: EmbedIndexFile: assertion failed; (*this).files.size() == (*this).consistent_data.files_len", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> EmbedIndexFile::decode(::futils::binary::reader& r) {
        ::futils::view::rvec tmp_12_ = {};
        if (!r.read_direct(tmp_12_, 5)) {
            return ::futils::error::Error<>("decode: EmbedIndexFile::magic: read string failed", ::futils::error::Category::lib);
        }
        if (tmp_12_ != ::futils::view::rvec("HWIDX", 5)) {
            return ::futils::error::Error<>("decode: EmbedIndexFile::magic: read string failed; not match to \"HWIDX\"", ::futils::error::Category::lib);
        }
        if (r.is_stream()) {
            return ::futils::error::Error<>("decode: EmbedIndexFile::files: read array failed; stream mode is currently not supported for fixed terminator", ::futils::error::Category::lib);
        }
        if (r.remain().size() < 48) {
            return ::futils::error::Error<>("decode: EmbedIndexFile::files: remain size is not enough; require 48", ::futils::error::Category::lib);
        }
        (*this).files.clear();
        while (r.remain().size() > 48) {
            EmbedFileIndex tmp_13_;
            if (auto err = tmp_13_.decode(r)) {
                return err;
            }
            (*this).files.push_back(std::move(tmp_13_));
        }
        if (auto err = (*this).consistent_data.decode(r)) {
            return err;
        }
        if (!((*this).files.size() == (*this).consistent_data.files_len)) {
            return ::futils::error::Error<>("decode: EmbedIndexFile: assertion failed; (*this).files.size() == (*this).consistent_data.files_len", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
}  // namespace embed
