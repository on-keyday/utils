// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
enum class UIState {
    start = 0,
    confrontation = 1,
    save_data_select = 2,
    create_save_data = 3,
    delete_save_data = 4,
    ending = 5,
    game_start = 6,
};
constexpr const char* to_string(UIState e) {
    switch (e) {
        case UIState::start:
            return "start";
        case UIState::confrontation:
            return "confrontation";
        case UIState::save_data_select:
            return "save_data_select";
        case UIState::create_save_data:
            return "create_save_data";
        case UIState::delete_save_data:
            return "delete_save_data";
        case UIState::ending:
            return "ending";
        case UIState::game_start:
            return "game_start";
    }
    return "";
}

constexpr std::optional<UIState> UIState_from_string(std::string_view str) {
    if (str.empty()) {
        return std::nullopt;
    }
    if (str == "start") {
        return UIState::start;
    }
    if (str == "confrontation") {
        return UIState::confrontation;
    }
    if (str == "save_data_select") {
        return UIState::save_data_select;
    }
    if (str == "create_save_data") {
        return UIState::create_save_data;
    }
    if (str == "delete_save_data") {
        return UIState::delete_save_data;
    }
    if (str == "ending") {
        return UIState::ending;
    }
    if (str == "game_start") {
        return UIState::game_start;
    }
    return std::nullopt;
}
enum class StoryPhase {
    prologue = 0,
};
constexpr const char* to_string(StoryPhase e) {
    switch (e) {
        case StoryPhase::prologue:
            return "prologue";
    }
    return "";
}

constexpr std::optional<StoryPhase> StoryPhase_from_string(std::string_view str) {
    if (str.empty()) {
        return std::nullopt;
    }
    if (str == "prologue") {
        return StoryPhase::prologue;
    }
    return std::nullopt;
}
enum class Location {
    hello_island = 0,
};
constexpr const char* to_string(Location e) {
    switch (e) {
        case Location::hello_island:
            return "hello_island";
    }
    return "";
}

constexpr std::optional<Location> Location_from_string(std::string_view str) {
    if (str.empty()) {
        return std::nullopt;
    }
    if (str == "hello_island") {
        return Location::hello_island;
    }
    return std::nullopt;
}
enum class ItemID {
    none = 0,
};
constexpr const char* to_string(ItemID e) {
    switch (e) {
        case ItemID::none:
            return "none";
    }
    return "";
}

constexpr std::optional<ItemID> ItemID_from_string(std::string_view str) {
    if (str.empty()) {
        return std::nullopt;
    }
    if (str == "none") {
        return ItemID::none;
    }
    return std::nullopt;
}
struct StoryFlags {
    std::uint64_t reserved = 0;
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 8;
};
inline ::futils::error::Error<> StoryFlags::encode(::futils::binary::writer& w) const {
    if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).reserved), true)) {
        return ::futils::error::Error<>("encode: StoryFlags::reserved: write std::uint64_t failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> StoryFlags::decode(::futils::binary::reader& r) {
    if (!::futils::binary::read_num(r, (*this).reserved, true)) {
        return ::futils::error::Error<>("decode: StoryFlags::reserved: read int failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
struct Item {
    ItemID id{};
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 1;
};
inline ::futils::error::Error<> Item::encode(::futils::binary::writer& w) const {
    auto tmp_0_ = static_cast<std::uint8_t>((*this).id);
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>(tmp_0_), true)) {
        return ::futils::error::Error<>("encode: Item::id: write std::uint8_t failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> Item::decode(::futils::binary::reader& r) {
    std::uint8_t tmp_1_ = 0;
    if (!::futils::binary::read_num(r, tmp_1_, true)) {
        return ::futils::error::Error<>("decode: Item::id: read int failed", ::futils::error::Category::lib);
    }
    (*this).id = static_cast<ItemID>(tmp_1_);
    return ::futils::error::Error<>();
}
struct Varint {
    ::futils::binary::flags_t<std::uint64_t, 2, 62> flags_3_;
    bits_flag_alias_method(flags_3_, 0, prefix);
    bits_flag_alias_method(flags_3_, 1, value);
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 0;
};
inline ::futils::error::Error<> Varint::encode(::futils::binary::writer& w) const {
    if ((*this).prefix() == 0) {
        std::uint8_t tmp4 = 0;
        tmp4 = (*this).value();
        tmp4 |= std::uint8_t(0) << 6;
        if (!::futils::binary::write_num(w, tmp4, true)) {
            return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
        }
    }
    else if ((*this).prefix() == 1) {
        std::uint16_t tmp4 = 0;
        tmp4 = (*this).value();
        tmp4 |= std::uint16_t(1) << 14;
        if (!::futils::binary::write_num(w, tmp4, true)) {
            return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
        }
    }
    else if ((*this).prefix() == 2) {
        std::uint32_t tmp4 = 0;
        tmp4 = (*this).value();
        tmp4 |= std::uint32_t(2) << 30;
        if (!::futils::binary::write_num(w, tmp4, true)) {
            return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
        }
    }
    else if ((*this).prefix() == 3) {
        std::uint64_t tmp4 = 0;
        tmp4 = (*this).value();
        tmp4 |= std::uint64_t(3) << 62;
        if (!::futils::binary::write_num(w, tmp4, true)) {
            return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
        }
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> Varint::decode(::futils::binary::reader& r) {
    if (!r.load_stream(1)) {
        return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
    }
    std::uint8_t tmp5 = (r.top() >> 6) & 0x3;
    (*this).prefix(tmp5);
    if ((*this).prefix() == 0) {
        std::uint8_t tmp6 = 0;
        if (!::futils::binary::read_num(r, tmp6, true)) {
            return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
        }
        tmp6 &= ~(std::uint8_t(0x3) << 6);
        (*this).value(tmp6);
    }
    else if ((*this).prefix() == 1) {
        std::uint16_t tmp7 = 0;
        if (!::futils::binary::read_num(r, tmp7, true)) {
            return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
        }
        tmp7 &= ~(std::uint16_t(0x3) << 14);
        (*this).value(tmp7);
    }
    else if ((*this).prefix() == 2) {
        std::uint32_t tmp8 = 0;
        if (!::futils::binary::read_num(r, tmp8, true)) {
            return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
        }
        tmp8 &= ~(std::uint32_t(0x3) << 30);
        (*this).value(tmp8);
    }
    else if ((*this).prefix() == 3) {
        std::uint64_t tmp9 = 0;
        if (!::futils::binary::read_num(r, tmp9, true)) {
            return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
        }
        tmp9 &= ~(std::uint64_t(0x3) << 62);
        (*this).value(tmp9);
    }
    return ::futils::error::Error<>();
}
struct EmbedFS {
    ::futils::view::rvec data;
    std::uint64_t files_len = 0;
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
};
inline ::futils::error::Error<> EmbedFS::encode(::futils::binary::writer& w) const {
    if (!w.write((*this).data)) {
        return ::futils::error::Error<>("encode: EmbedFS::data: write array failed", ::futils::error::Category::lib);
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).files_len), true)) {
        return ::futils::error::Error<>("encode: EmbedFS::files_len: write std::uint64_t failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> EmbedFS::decode(::futils::binary::reader& r) {
    if (r.is_stream()) {
        return ::futils::error::Error<>("decode: EmbedFS::data: read array failed; stream mode is currently not supported for fixed terminator", ::futils::error::Category::lib);
    }
    if (r.remain().size() < 8) {
        return ::futils::error::Error<>("decode: EmbedFS::data: remain size is not enough; require 8", ::futils::error::Category::lib);
    }
    if (!r.read((*this).data, (r.remain().size() - 8))) {
        return ::futils::error::Error<>("decode: EmbedFS::data: read byte array failed", ::futils::error::Category::lib);
    }
    if (!::futils::binary::read_num(r, (*this).files_len, true)) {
        return ::futils::error::Error<>("decode: EmbedFS::files_len: read int failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
struct PlayerData {
    std::array<Item, 10> items;
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 10;
};
inline ::futils::error::Error<> PlayerData::encode(::futils::binary::writer& w) const {
    for (auto& tmp_10_ : (*this).items) {
        if (auto err = tmp_10_.encode(w)) {
            return err;
        }
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> PlayerData::decode(::futils::binary::reader& r) {
    for (size_t tmp_12_ = 0; tmp_12_ < 10; ++tmp_12_) {
        if (auto err = (*this).items[tmp_12_].decode(r)) {
            return err;
        }
    }
    return ::futils::error::Error<>();
}
struct Name {
    Varint len;
    ::futils::view::rvec name;
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
};
inline ::futils::error::Error<> Name::encode(::futils::binary::writer& w) const {
    if (auto err = (*this).len.encode(w)) {
        return err;
    }
    auto tmp_13_ = (*this).len.value();
    if (tmp_13_ != (*this).name.size()) {
        return ::futils::error::Error<>("encode: Name::name: dynamic length is not compatible with its length; tmp_13_!=(*this).name.size()", ::futils::error::Category::lib);
    }
    if (!w.write((*this).name)) {
        return ::futils::error::Error<>("encode: Name::name: write array failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> Name::decode(::futils::binary::reader& r) {
    if (auto err = (*this).len.decode(r)) {
        return err;
    }
    auto tmp_14_ = (*this).len.value();
    if (!r.read((*this).name, tmp_14_)) {
        return ::futils::error::Error<>("decode: Name::name: read byte array failed", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
struct SaveData {
    std::uint8_t version = 0;
    StoryPhase phase{};
    Location location{};
    std::uint8_t players_len = 0;
    std::vector<PlayerData> players;
    bool set_players(auto&& v) {
        if (v.size() > 0xff) {
            return false;
        }
        (*this).players_len = v.size();
        (*this).players = std::forward<decltype(v)>(v);
        return true;
    }
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
    static constexpr size_t fixed_header_size = 7;
};
inline ::futils::error::Error<> SaveData::encode(::futils::binary::writer& w) const {
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).version), true)) {
        return ::futils::error::Error<>("encode: SaveData::version: write std::uint8_t failed", ::futils::error::Category::lib);
    }
    auto tmp_15_ = static_cast<std::uint32_t>((*this).phase);
    if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(tmp_15_), true)) {
        return ::futils::error::Error<>("encode: SaveData::phase: write std::uint32_t failed", ::futils::error::Category::lib);
    }
    auto tmp_16_ = static_cast<std::uint8_t>((*this).location);
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>(tmp_16_), true)) {
        return ::futils::error::Error<>("encode: SaveData::location: write std::uint8_t failed", ::futils::error::Category::lib);
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).players_len), true)) {
        return ::futils::error::Error<>("encode: SaveData::players_len: write std::uint8_t failed", ::futils::error::Category::lib);
    }
    auto tmp_17_ = (*this).players_len;
    if (tmp_17_ != (*this).players.size()) {
        return ::futils::error::Error<>("encode: SaveData::players: dynamic length is not compatible with its length; tmp_17_!=(*this).players.size()", ::futils::error::Category::lib);
    }
    for (auto& tmp_18_ : (*this).players) {
        if (auto err = tmp_18_.encode(w)) {
            return err;
        }
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> SaveData::decode(::futils::binary::reader& r) {
    if (!::futils::binary::read_num(r, (*this).version, true)) {
        return ::futils::error::Error<>("decode: SaveData::version: read int failed", ::futils::error::Category::lib);
    }
    std::uint32_t tmp_19_ = 0;
    if (!::futils::binary::read_num(r, tmp_19_, true)) {
        return ::futils::error::Error<>("decode: SaveData::phase: read int failed", ::futils::error::Category::lib);
    }
    (*this).phase = static_cast<StoryPhase>(tmp_19_);
    std::uint8_t tmp_20_ = 0;
    if (!::futils::binary::read_num(r, tmp_20_, true)) {
        return ::futils::error::Error<>("decode: SaveData::location: read int failed", ::futils::error::Category::lib);
    }
    (*this).location = static_cast<Location>(tmp_20_);
    if (!::futils::binary::read_num(r, (*this).players_len, true)) {
        return ::futils::error::Error<>("decode: SaveData::players_len: read int failed", ::futils::error::Category::lib);
    }
    auto tmp_21_ = (*this).players_len;
    (*this).players.clear();
    for (size_t tmp_23_ = 0; tmp_23_ < tmp_21_; ++tmp_23_) {
        PlayerData tmp_22_;
        if (auto err = tmp_22_.decode(r)) {
            return err;
        }
        (*this).players.push_back(std::move(tmp_22_));
    }
    return ::futils::error::Error<>();
}
struct EmbedFileIndex {
    Name name;
    Varint len;
    Varint offset;
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
};
inline ::futils::error::Error<> EmbedFileIndex::encode(::futils::binary::writer& w) const {
    if (auto err = (*this).name.encode(w)) {
        return err;
    }
    if (auto err = (*this).len.encode(w)) {
        return err;
    }
    if (auto err = (*this).offset.encode(w)) {
        return err;
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> EmbedFileIndex::decode(::futils::binary::reader& r) {
    if (auto err = (*this).name.decode(r)) {
        return err;
    }
    if (auto err = (*this).len.decode(r)) {
        return err;
    }
    if (auto err = (*this).offset.decode(r)) {
        return err;
    }
    return ::futils::error::Error<>();
}
struct EmbedIndexFile {
    std::vector<EmbedFileIndex> files;
    std::uint64_t files_len = 0;
    ::futils::error::Error<> encode(::futils::binary::writer& w) const;
    ::futils::error::Error<> decode(::futils::binary::reader& r);
};
inline ::futils::error::Error<> EmbedIndexFile::encode(::futils::binary::writer& w) const {
    for (auto& tmp_24_ : (*this).files) {
        if (auto err = tmp_24_.encode(w)) {
            return err;
        }
    }
    if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).files_len), true)) {
        return ::futils::error::Error<>("encode: EmbedIndexFile::files_len: write std::uint64_t failed", ::futils::error::Category::lib);
    }
    if (!((*this).files.size() == (*this).files_len)) {
        return ::futils::error::Error<>("encode: EmbedIndexFile: assertion failed; (*this).files.size() == (*this).files_len", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
inline ::futils::error::Error<> EmbedIndexFile::decode(::futils::binary::reader& r) {
    if (r.is_stream()) {
        return ::futils::error::Error<>("decode: EmbedIndexFile::files: read array failed; stream mode is currently not supported for fixed terminator", ::futils::error::Category::lib);
    }
    if (r.remain().size() < 8) {
        return ::futils::error::Error<>("decode: EmbedIndexFile::files: remain size is not enough; require 8", ::futils::error::Category::lib);
    }
    (*this).files.clear();
    for (size_t tmp_26_ = 0; tmp_26_ < (r.remain().size() - 8); ++tmp_26_) {
        EmbedFileIndex tmp_25_;
        if (auto err = tmp_25_.decode(r)) {
            return err;
        }
        (*this).files.push_back(std::move(tmp_25_));
    }
    if (!::futils::binary::read_num(r, (*this).files_len, true)) {
        return ::futils::error::Error<>("decode: EmbedIndexFile::files_len: read int failed", ::futils::error::Category::lib);
    }
    if (!((*this).files.size() == (*this).files_len)) {
        return ::futils::error::Error<>("decode: EmbedIndexFile: assertion failed; (*this).files.size() == (*this).files_len", ::futils::error::Category::lib);
    }
    return ::futils::error::Error<>();
}
