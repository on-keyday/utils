// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>
#include <string_view>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
#include <string>
namespace save {
    enum class UIState : std::uint8_t {
        start = 0,
        confrontation = 1,
        save_data_select = 2,
        create_save_data = 3,
        delete_save_data = 4,
        ending = 5,
        game_start = 6,
    };
    constexpr const char* to_string(UIState e) {
        switch (e) {
            case UIState::start:
                return "start";
            case UIState::confrontation:
                return "confrontation";
            case UIState::save_data_select:
                return "save_data_select";
            case UIState::create_save_data:
                return "create_save_data";
            case UIState::delete_save_data:
                return "delete_save_data";
            case UIState::ending:
                return "ending";
            case UIState::game_start:
                return "game_start";
        }
        return "";
    }

    constexpr std::optional<UIState> UIState_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "start") {
            return UIState::start;
        }
        if (str == "confrontation") {
            return UIState::confrontation;
        }
        if (str == "save_data_select") {
            return UIState::save_data_select;
        }
        if (str == "create_save_data") {
            return UIState::create_save_data;
        }
        if (str == "delete_save_data") {
            return UIState::delete_save_data;
        }
        if (str == "ending") {
            return UIState::ending;
        }
        if (str == "game_start") {
            return UIState::game_start;
        }
        return std::nullopt;
    }
    enum class ItemID : std::uint8_t {
        none = 0,
    };
    constexpr const char* to_string(ItemID e) {
        switch (e) {
            case ItemID::none:
                return "none";
        }
        return "";
    }

    constexpr std::optional<ItemID> ItemID_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "none") {
            return ItemID::none;
        }
        return std::nullopt;
    }
    enum class ActionID : std::uint8_t {
        none = 0,
    };
    constexpr const char* to_string(ActionID e) {
        switch (e) {
            case ActionID::none:
                return "none";
        }
        return "";
    }

    constexpr std::optional<ActionID> ActionID_from_string(std::string_view str) {
        if (str.empty()) {
            return std::nullopt;
        }
        if (str == "none") {
            return ActionID::none;
        }
        return std::nullopt;
    }
    struct StoryFlags {
        std::uint64_t reserved = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> StoryFlags::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).reserved), true)) {
            return ::futils::error::Error<>("encode: StoryFlags::reserved: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> StoryFlags::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).reserved, true)) {
            return ::futils::error::Error<>("decode: StoryFlags::reserved: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct Varint {
        ::futils::binary::flags_t<std::uint64_t, 2, 62> flags_1_;
        bits_flag_alias_method(flags_1_, 0, prefix);
        bits_flag_alias_method(flags_1_, 1, value);
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 0;
    };
    inline ::futils::error::Error<> Varint::encode(::futils::binary::writer& w) const {
        if ((*this).prefix() == 0) {
            std::uint8_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint8_t(0) << 6;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        else if ((*this).prefix() == 1) {
            std::uint16_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint16_t(1) << 14;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        else if ((*this).prefix() == 2) {
            std::uint32_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint32_t(2) << 30;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        else if ((*this).prefix() == 3) {
            std::uint64_t tmp2 = 0;
            tmp2 = (*this).value();
            tmp2 |= std::uint64_t(3) << 62;
            if (!::futils::binary::write_num(w, tmp2, true)) {
                return ::futils::error::Error<>("encode: Varint::value: write bit field failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Varint::decode(::futils::binary::reader& r) {
        if (!r.load_stream(1)) {
            return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
        }
        std::uint8_t tmp3 = (r.top() >> 6) & 0x3;
        (*this).prefix(tmp3);
        if ((*this).prefix() == 0) {
            std::uint8_t tmp4 = 0;
            if (!::futils::binary::read_num(r, tmp4, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp4 &= ~(std::uint8_t(0x3) << 6);
            (*this).value(tmp4);
        }
        else if ((*this).prefix() == 1) {
            std::uint16_t tmp5 = 0;
            if (!::futils::binary::read_num(r, tmp5, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp5 &= ~(std::uint16_t(0x3) << 14);
            (*this).value(tmp5);
        }
        else if ((*this).prefix() == 2) {
            std::uint32_t tmp6 = 0;
            if (!::futils::binary::read_num(r, tmp6, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp6 &= ~(std::uint32_t(0x3) << 30);
            (*this).value(tmp6);
        }
        else if ((*this).prefix() == 3) {
            std::uint64_t tmp7 = 0;
            if (!::futils::binary::read_num(r, tmp7, true)) {
                return ::futils::error::Error<>("decode: Varint::value: read bit field failed", ::futils::error::Category::lib);
            }
            tmp7 &= ~(std::uint64_t(0x3) << 62);
            (*this).value(tmp7);
        }
        return ::futils::error::Error<>();
    }
    struct Item {
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> Item::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).id.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Item::decode(::futils::binary::reader& r) {
        if (auto err = (*this).id.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct Action {
        Varint id;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> Action::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).id.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Action::decode(::futils::binary::reader& r) {
        if (auto err = (*this).id.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct Name {
        Varint len;
        std::string name;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> Name::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).len.encode(w)) {
            return err;
        }
        auto tmp_8_ = (*this).len.value();
        if (tmp_8_ != (*this).name.size()) {
            return ::futils::error::Error<>("encode: Name::name: dynamic length is not compatible with its length; tmp_8_!=(*this).name.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).name)) {
            return ::futils::error::Error<>("encode: Name::name: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Name::decode(::futils::binary::reader& r) {
        if (auto err = (*this).len.decode(r)) {
            return err;
        }
        auto tmp_9_ = (*this).len.value();
        if (!r.read((*this).name, tmp_9_)) {
            return ::futils::error::Error<>("decode: Name::name: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct PlayerData {
        Name name;
        std::uint8_t max_items = 0;
        std::uint8_t max_actions = 0;
        std::uint8_t item_len = 0;
        std::vector<Item> items;
        bool set_items(auto&& v) {
            if (v.size() > 0xff) {
                return false;
            }
            (*this).item_len = v.size();
            (*this).items = std::forward<decltype(v)>(v);
            return true;
        }
        std::uint8_t action_len = 0;
        std::vector<Action> actions;
        bool set_actions(auto&& v) {
            if (v.size() > 0xff) {
                return false;
            }
            (*this).action_len = v.size();
            (*this).actions = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> PlayerData::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).max_items), true)) {
            return ::futils::error::Error<>("encode: PlayerData::max_items: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).max_actions), true)) {
            return ::futils::error::Error<>("encode: PlayerData::max_actions: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).item_len), true)) {
            return ::futils::error::Error<>("encode: PlayerData::item_len: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        auto tmp_10_ = (*this).item_len;
        if (tmp_10_ != (*this).items.size()) {
            return ::futils::error::Error<>("encode: PlayerData::items: dynamic length is not compatible with its length; tmp_10_!=(*this).items.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_11_ : (*this).items) {
            if (auto err = tmp_11_.encode(w)) {
                return err;
            }
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).action_len), true)) {
            return ::futils::error::Error<>("encode: PlayerData::action_len: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        auto tmp_12_ = (*this).action_len;
        if (tmp_12_ != (*this).actions.size()) {
            return ::futils::error::Error<>("encode: PlayerData::actions: dynamic length is not compatible with its length; tmp_12_!=(*this).actions.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_13_ : (*this).actions) {
            if (auto err = tmp_13_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PlayerData::decode(::futils::binary::reader& r) {
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).max_items, true)) {
            return ::futils::error::Error<>("decode: PlayerData::max_items: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).max_actions, true)) {
            return ::futils::error::Error<>("decode: PlayerData::max_actions: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).item_len, true)) {
            return ::futils::error::Error<>("decode: PlayerData::item_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_14_ = (*this).item_len;
        (*this).items.clear();
        for (size_t tmp_16_ = 0; tmp_16_ < tmp_14_; ++tmp_16_) {
            Item tmp_15_;
            if (auto err = tmp_15_.decode(r)) {
                return err;
            }
            (*this).items.push_back(std::move(tmp_15_));
        }
        if (!::futils::binary::read_num(r, (*this).action_len, true)) {
            return ::futils::error::Error<>("decode: PlayerData::action_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_17_ = (*this).action_len;
        (*this).actions.clear();
        for (size_t tmp_19_ = 0; tmp_19_ < tmp_17_; ++tmp_19_) {
            Action tmp_18_;
            if (auto err = tmp_18_.decode(r)) {
                return err;
            }
            (*this).actions.push_back(std::move(tmp_18_));
        }
        return ::futils::error::Error<>();
    }
    struct SaveData {
        std::uint8_t version = 0;
        Name phase;
        Name location;
        std::uint8_t players_len = 0;
        std::vector<PlayerData> players;
        bool set_players(auto&& v) {
            if (v.size() > 0xff) {
                return false;
            }
            (*this).players_len = v.size();
            (*this).players = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    inline ::futils::error::Error<> SaveData::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).version), true)) {
            return ::futils::error::Error<>("encode: SaveData::version: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).phase.encode(w)) {
            return err;
        }
        if (auto err = (*this).location.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).players_len), true)) {
            return ::futils::error::Error<>("encode: SaveData::players_len: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        auto tmp_20_ = (*this).players_len;
        if (tmp_20_ != (*this).players.size()) {
            return ::futils::error::Error<>("encode: SaveData::players: dynamic length is not compatible with its length; tmp_20_!=(*this).players.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_21_ : (*this).players) {
            if (auto err = tmp_21_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> SaveData::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).version, true)) {
            return ::futils::error::Error<>("decode: SaveData::version: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).phase.decode(r)) {
            return err;
        }
        if (auto err = (*this).location.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).players_len, true)) {
            return ::futils::error::Error<>("decode: SaveData::players_len: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_22_ = (*this).players_len;
        (*this).players.clear();
        for (size_t tmp_24_ = 0; tmp_24_ < tmp_22_; ++tmp_24_) {
            PlayerData tmp_23_;
            if (auto err = tmp_23_.decode(r)) {
                return err;
            }
            (*this).players.push_back(std::move(tmp_23_));
        }
        return ::futils::error::Error<>();
    }
}  // namespace save
