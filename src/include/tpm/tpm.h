// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
#include <error/error.h>
namespace futils::tpm2 {
    struct SessionState {
        bool hasSession = false;
    };
    enum class TPMAlgorithmID {
        TPM_ALG_ERROR = 0x0000,
        TPM_ALG_RSA = 0x0001,
        TPM_ALG_SHA = 0x0004,
        TPM_ALG_SHA1 = TPMAlgorithmID::TPM_ALG_SHA,
        TPM_ALG_HMAC = 0x0005,
        TPM_ALG_AES = 0x0006,
        TPM_ALG_MGF1 = 0x0007,
        TPM_ALG_KEYEDHASH = 0x0008,
        TPM_ALG_XOR = 0x000A,
        TPM_ALG_SHA256 = 0x000B,
        TPM_ALG_SHA384 = 0x000C,
        TPM_ALG_SHA512 = 0x000D,
        TPM_ALG_NULL = 0x0010,
        TPM_ALG_SM3_256 = 0x0012,
        TPM_ALG_SM4 = 0x0013,
        TPM_ALG_RSASSA = 0x0014,
        TPM_ALG_RSAES = 0x0015,
        TPM_ALG_RSAPSS = 0x0016,
        TPM_ALG_OAEP = 0x0017,
        TPM_ALG_ECDSA = 0x0018,
        TPM_ALG_ECDH = 0x0019,
        TPM_ALG_ECDAA = 0x001A,
        TPM_ALG_SM2 = 0x001B,
        TPM_ALG_ECSCHNORR = 0x001C,
        TPM_ALG_ECMQV = 0x001D,
        TPM_ALG_KDF1_SP800_56A = 0x0020,
        TPM_ALG_KDF2 = 0x0021,
        TPM_ALG_KDF1_SP800_108 = 0x0022,
        TPM_ALG_ECC = 0x0023,
        TPM_ALG_SYMCIPHER = 0x0025,
        TPM_ALG_CAMELLIA = 0x0026,
        TPM_ALG_CTR = 0x0040,
        TPM_ALG_OFB = 0x0041,
        TPM_ALG_CBC = 0x0042,
        TPM_ALG_CFB = 0x0043,
        TPM_ALG_ECB = 0x0044,
    };
    constexpr auto TPM_GENERATED_VALUE = 0xff544347;
    enum class TPMAttestType {
        CERTIFY = 0,
        CREATION = 1,
        QUOTE = 2,
        COMMAND_AUDIT = 3,
        SESSION_AUDIT = 4,
        TIME = 5,
        NV = 6,
    };
    enum class TPMTag {
        TPM_ST_RSP_COMMAND = 0x00C4,
        TPM_ST_NULL = 0X8000,
        TPM_ST_NO_SESSIONS = 0x8001,
        TPM_ST_SESSIONS = 0x8002,
        TPM_ST_ATTEST_NV = 0x8014,
        TPM_ST_ATTEST_COMMAND_AUDIT = 0x8015,
        TPM_ST_ATTEST_SESSION_AUDIT = 0x8016,
        TPM_ST_ATTEST_CERTIFY = 0x8017,
        TPM_ST_ATTEST_QUOTE = 0x8018,
        TPM_ST_ATTEST_TIME = 0x8019,
        TPM_ST_ATTEST_CREATION = 0x801A,
        TPM_ST_CREATION = 0x8021,
        TPM_ST_VERIFIED = 0x8022,
        TPM_ST_AUTH_SECRET = 0x8023,
        TPM_ST_HASHCHECK = 0x8024,
        TPM_ST_AUTH_SIGNED = 0x8025,
        TPM_ST_FU_MANIFEST = 0x8029,
    };
    enum class TPMCapability {
        TPM_CAP_FIRST = 0x00000000,
        TPM_CAP_HANDLES = 0x00000001,
        TPM_CAP_COMMANDS = 0x00000002,
        TPM_CAP_PP_COMMANDS = 0x00000003,
        TPM_CAP_AUDIT_COMMANDS = 0x00000004,
        TPM_CAP_PCRS = 0x00000005,
        TPM_CAP_TPM_PROPERTIES = 0x00000006,
        TPM_CAP_PCR_PROPERTIES = 0x00000007,
        TPM_CAP_ECC_CURVES = 0x00000008,
        TPM_CAP_VENDOR_PROPERTY = 0x00000100,
    };
    struct Bytes8 {
        std::uint8_t size = 0;
        ::futils::view::rvec data;
        bool set_data(auto&& v) {
            if (v.size() > ~std::uint8_t(0)) {
                return false;
            }
            (*this).size = v.size();
            (*this).data = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    inline ::futils::error::Error<> Bytes8::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).size), true)) {
            return ::futils::error::Error<>("encode: Bytes8::size: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        auto tmp_0_ = (*this).size;
        if (tmp_0_ != (*this).data.size()) {
            return ::futils::error::Error<>("encode: Bytes8::data: dynamic length is not compatible with its length; tmp_0_!=(*this).data.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).data)) {
            return ::futils::error::Error<>("encode: Bytes8::data: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Bytes8::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).size, true)) {
            return ::futils::error::Error<>("decode: Bytes8::size: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_1_ = (*this).size;
        if (!r.read((*this).data, tmp_1_)) {
            return ::futils::error::Error<>("decode: Bytes8::data: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct Bytes16 {
        std::uint16_t size = 0;
        ::futils::view::rvec data;
        bool set_data(auto&& v) {
            if (v.size() > ~std::uint16_t(0)) {
                return false;
            }
            (*this).size = v.size();
            (*this).data = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> Bytes16::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).size), true)) {
            return ::futils::error::Error<>("encode: Bytes16::size: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_2_ = (*this).size;
        if (tmp_2_ != (*this).data.size()) {
            return ::futils::error::Error<>("encode: Bytes16::data: dynamic length is not compatible with its length; tmp_2_!=(*this).data.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).data)) {
            return ::futils::error::Error<>("encode: Bytes16::data: write array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Bytes16::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).size, true)) {
            return ::futils::error::Error<>("decode: Bytes16::size: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_3_ = (*this).size;
        if (!r.read((*this).data, tmp_3_)) {
            return ::futils::error::Error<>("decode: Bytes16::data: read byte array failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMSymetricCrypto {
        std::uint16_t keyBits = 0;
        std::uint16_t mode = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPMSymetricCrypto::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).keyBits), true)) {
            return ::futils::error::Error<>("encode: TPMSymetricCrypto::keyBits: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).mode), true)) {
            return ::futils::error::Error<>("encode: TPMSymetricCrypto::mode: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMSymetricCrypto::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).keyBits, true)) {
            return ::futils::error::Error<>("decode: TPMSymetricCrypto::keyBits: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).mode, true)) {
            return ::futils::error::Error<>("decode: TPMSymetricCrypto::mode: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMSymetricXor {
        std::uint16_t xorr = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMSymetricXor::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).xorr), true)) {
            return ::futils::error::Error<>("encode: TPMSymetricXor::xorr: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMSymetricXor::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).xorr, true)) {
            return ::futils::error::Error<>("decode: TPMSymetricXor::xorr: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMScheme {
        TPMAlgorithmID scheme{};
        struct union_struct_6 {
            TPMAlgorithmID hashAlg{};
        };
        std::variant<std::monostate, union_struct_6> union_variant_5;
        std::optional<TPMAlgorithmID> hashAlg() const {
            if ((*this).scheme != TPMAlgorithmID::TPM_ALG_NULL == true) {
                if (!std::holds_alternative<union_struct_6>(union_variant_5)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_5).hashAlg;
            }
            return std::nullopt;
        }
        bool hashAlg(const TPMAlgorithmID& v) {
            if ((*this).scheme != TPMAlgorithmID::TPM_ALG_NULL == true) {
                if (!std::holds_alternative<union_struct_6>(union_variant_5)) {
                    union_variant_5 = union_struct_6();
                }
                std::get<1>((*this).union_variant_5).hashAlg = v;
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMScheme::encode(::futils::binary::writer& w) const {
        auto tmp_7_ = static_cast<std::uint16_t>((*this).scheme);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_7_), true)) {
            return ::futils::error::Error<>("encode: TPMScheme::scheme: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if ((*this).scheme != TPMAlgorithmID::TPM_ALG_NULL) {
            if (!std::holds_alternative<union_struct_6>(union_variant_5)) {
                return ::futils::error::Error<>("encode: TPMScheme: union_variant_5 variant alternative union_struct_6 is not set", ::futils::error::Category::lib);
            }
            auto tmp_8_ = static_cast<std::uint16_t>(std::get<1>((*this).union_variant_5).hashAlg);
            if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_8_), true)) {
                return ::futils::error::Error<>("encode: TPMScheme::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMScheme::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_9_ = 0;
        if (!::futils::binary::read_num(r, tmp_9_, true)) {
            return ::futils::error::Error<>("decode: TPMScheme::scheme: read int failed", ::futils::error::Category::lib);
        }
        (*this).scheme = static_cast<TPMAlgorithmID>(tmp_9_);
        if ((*this).scheme != TPMAlgorithmID::TPM_ALG_NULL) {
            if (!std::holds_alternative<union_struct_6>(union_variant_5)) {
                union_variant_5 = union_struct_6();
            }
            std::uint16_t tmp_10_ = 0;
            if (!::futils::binary::read_num(r, tmp_10_, true)) {
                return ::futils::error::Error<>("decode: TPMScheme::hashAlg: read int failed", ::futils::error::Category::lib);
            }
            std::get<1>((*this).union_variant_5).hashAlg = static_cast<TPMAlgorithmID>(tmp_10_);
        }
        return ::futils::error::Error<>();
    }
    struct PublicParamSymCipher {
        TPMAlgorithmID algorithm{};
        std::uint16_t keyBits = 0;
        std::uint16_t mode = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 6;
    };
    inline ::futils::error::Error<> PublicParamSymCipher::encode(::futils::binary::writer& w) const {
        auto tmp_11_ = static_cast<std::uint16_t>((*this).algorithm);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_11_), true)) {
            return ::futils::error::Error<>("encode: PublicParamSymCipher::algorithm: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).keyBits), true)) {
            return ::futils::error::Error<>("encode: PublicParamSymCipher::keyBits: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).mode), true)) {
            return ::futils::error::Error<>("encode: PublicParamSymCipher::mode: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PublicParamSymCipher::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_12_ = 0;
        if (!::futils::binary::read_num(r, tmp_12_, true)) {
            return ::futils::error::Error<>("decode: PublicParamSymCipher::algorithm: read int failed", ::futils::error::Category::lib);
        }
        (*this).algorithm = static_cast<TPMAlgorithmID>(tmp_12_);
        if (!::futils::binary::read_num(r, (*this).keyBits, true)) {
            return ::futils::error::Error<>("decode: PublicParamSymCipher::keyBits: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).mode, true)) {
            return ::futils::error::Error<>("decode: PublicParamSymCipher::mode: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct SignatureHMAC {
        TPMAlgorithmID hash{};
        struct union_struct_15 {
            std::array<std::uint8_t, 20> hmac;
        };
        struct union_struct_16 {
            std::array<std::uint8_t, 32> hmac;
        };
        struct union_struct_17 {
            std::array<std::uint8_t, 48> hmac;
        };
        struct union_struct_18 {
            std::array<std::uint8_t, 64> hmac;
        };
        std::variant<std::monostate, union_struct_15, union_struct_16, union_struct_17, union_struct_18> union_variant_14;
        std::optional<::futils::view::rvec> hmac() const {
            if (TPMAlgorithmID::TPM_ALG_SHA1 == (*this).hash) {
                if (!std::holds_alternative<union_struct_15>(union_variant_14)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_14).hmac;
            }
            if (TPMAlgorithmID::TPM_ALG_SHA256 == (*this).hash) {
                if (!std::holds_alternative<union_struct_16>(union_variant_14)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_14).hmac;
            }
            if (TPMAlgorithmID::TPM_ALG_SHA384 == (*this).hash) {
                if (!std::holds_alternative<union_struct_17>(union_variant_14)) {
                    return std::nullopt;
                }
                return std::get<3>((*this).union_variant_14).hmac;
            }
            if (TPMAlgorithmID::TPM_ALG_SHA512 == (*this).hash) {
                if (!std::holds_alternative<union_struct_18>(union_variant_14)) {
                    return std::nullopt;
                }
                return std::get<4>((*this).union_variant_14).hmac;
            }
            return std::nullopt;
        }
        bool hmac(const ::futils::view::rvec& v) {
            if (TPMAlgorithmID::TPM_ALG_SHA1 == (*this).hash) {
                if (!std::holds_alternative<union_struct_15>(union_variant_14)) {
                    union_variant_14 = union_struct_15();
                }
                if (v.size() != 20) {
                    return false;
                }
                std::copy(v.begin(), v.end(), std::get<1>((*this).union_variant_14).hmac.begin());
                return true;
            }
            if (TPMAlgorithmID::TPM_ALG_SHA256 == (*this).hash) {
                if (!std::holds_alternative<union_struct_16>(union_variant_14)) {
                    union_variant_14 = union_struct_16();
                }
                if (v.size() != 32) {
                    return false;
                }
                std::copy(v.begin(), v.end(), std::get<2>((*this).union_variant_14).hmac.begin());
                return true;
            }
            if (TPMAlgorithmID::TPM_ALG_SHA384 == (*this).hash) {
                if (!std::holds_alternative<union_struct_17>(union_variant_14)) {
                    union_variant_14 = union_struct_17();
                }
                if (v.size() != 48) {
                    return false;
                }
                std::copy(v.begin(), v.end(), std::get<3>((*this).union_variant_14).hmac.begin());
                return true;
            }
            if (TPMAlgorithmID::TPM_ALG_SHA512 == (*this).hash) {
                if (!std::holds_alternative<union_struct_18>(union_variant_14)) {
                    union_variant_14 = union_struct_18();
                }
                if (v.size() != 64) {
                    return false;
                }
                std::copy(v.begin(), v.end(), std::get<4>((*this).union_variant_14).hmac.begin());
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> SignatureHMAC::encode(::futils::binary::writer& w) const {
        auto tmp_19_ = static_cast<std::uint16_t>((*this).hash);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_19_), true)) {
            return ::futils::error::Error<>("encode: SignatureHMAC::hash: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (TPMAlgorithmID::TPM_ALG_SHA1 == (*this).hash) {
            if (!std::holds_alternative<union_struct_15>(union_variant_14)) {
                return ::futils::error::Error<>("encode: SignatureHMAC: union_variant_14 variant alternative union_struct_15 is not set", ::futils::error::Category::lib);
            }
            if (!w.write(std::get<1>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("encode: SignatureHMAC::hmac: write array failed", ::futils::error::Category::lib);
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SHA256 == (*this).hash) {
            if (!std::holds_alternative<union_struct_16>(union_variant_14)) {
                return ::futils::error::Error<>("encode: SignatureHMAC: union_variant_14 variant alternative union_struct_16 is not set", ::futils::error::Category::lib);
            }
            if (!w.write(std::get<2>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("encode: SignatureHMAC::hmac: write array failed", ::futils::error::Category::lib);
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SHA384 == (*this).hash) {
            if (!std::holds_alternative<union_struct_17>(union_variant_14)) {
                return ::futils::error::Error<>("encode: SignatureHMAC: union_variant_14 variant alternative union_struct_17 is not set", ::futils::error::Category::lib);
            }
            if (!w.write(std::get<3>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("encode: SignatureHMAC::hmac: write array failed", ::futils::error::Category::lib);
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SHA512 == (*this).hash) {
            if (!std::holds_alternative<union_struct_18>(union_variant_14)) {
                return ::futils::error::Error<>("encode: SignatureHMAC: union_variant_14 variant alternative union_struct_18 is not set", ::futils::error::Category::lib);
            }
            if (!w.write(std::get<4>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("encode: SignatureHMAC::hmac: write array failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> SignatureHMAC::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_20_ = 0;
        if (!::futils::binary::read_num(r, tmp_20_, true)) {
            return ::futils::error::Error<>("decode: SignatureHMAC::hash: read int failed", ::futils::error::Category::lib);
        }
        (*this).hash = static_cast<TPMAlgorithmID>(tmp_20_);
        if (TPMAlgorithmID::TPM_ALG_SHA1 == (*this).hash) {
            if (!std::holds_alternative<union_struct_15>(union_variant_14)) {
                union_variant_14 = union_struct_15();
            }
            if (!r.read(std::get<1>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("decode: SignatureHMAC::hmac: read byte array failed", ::futils::error::Category::lib);
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SHA256 == (*this).hash) {
            if (!std::holds_alternative<union_struct_16>(union_variant_14)) {
                union_variant_14 = union_struct_16();
            }
            if (!r.read(std::get<2>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("decode: SignatureHMAC::hmac: read byte array failed", ::futils::error::Category::lib);
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SHA384 == (*this).hash) {
            if (!std::holds_alternative<union_struct_17>(union_variant_14)) {
                union_variant_14 = union_struct_17();
            }
            if (!r.read(std::get<3>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("decode: SignatureHMAC::hmac: read byte array failed", ::futils::error::Category::lib);
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SHA512 == (*this).hash) {
            if (!std::holds_alternative<union_struct_18>(union_variant_14)) {
                union_variant_14 = union_struct_18();
            }
            if (!r.read(std::get<4>((*this).union_variant_14).hmac)) {
                return ::futils::error::Error<>("decode: SignatureHMAC::hmac: read byte array failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    struct ClockInfo {
        std::uint64_t clock = 0;
        std::uint32_t resetCount = 0;
        std::uint32_t restartCount = 0;
        std::uint8_t safe = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 17;
    };
    inline ::futils::error::Error<> ClockInfo::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).clock), true)) {
            return ::futils::error::Error<>("encode: ClockInfo::clock: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).resetCount), true)) {
            return ::futils::error::Error<>("encode: ClockInfo::resetCount: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).restartCount), true)) {
            return ::futils::error::Error<>("encode: ClockInfo::restartCount: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).safe), true)) {
            return ::futils::error::Error<>("encode: ClockInfo::safe: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> ClockInfo::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).clock, true)) {
            return ::futils::error::Error<>("decode: ClockInfo::clock: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).resetCount, true)) {
            return ::futils::error::Error<>("decode: ClockInfo::resetCount: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).restartCount, true)) {
            return ::futils::error::Error<>("decode: ClockInfo::restartCount: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).safe, true)) {
            return ::futils::error::Error<>("decode: ClockInfo::safe: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMPacketHeader {
        TPMTag tag{};
        std::uint32_t commandSize = 0;
        std::uint32_t commandCode = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 10;
    };
    inline ::futils::error::Error<> TPMPacketHeader::encode(::futils::binary::writer& w) const {
        auto tmp_21_ = static_cast<std::uint16_t>((*this).tag);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_21_), true)) {
            return ::futils::error::Error<>("encode: TPMPacketHeader::tag: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).commandSize), true)) {
            return ::futils::error::Error<>("encode: TPMPacketHeader::commandSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).commandCode), true)) {
            return ::futils::error::Error<>("encode: TPMPacketHeader::commandCode: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMPacketHeader::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_22_ = 0;
        if (!::futils::binary::read_num(r, tmp_22_, true)) {
            return ::futils::error::Error<>("decode: TPMPacketHeader::tag: read int failed", ::futils::error::Category::lib);
        }
        (*this).tag = static_cast<TPMTag>(tmp_22_);
        if (!::futils::binary::read_num(r, (*this).commandSize, true)) {
            return ::futils::error::Error<>("decode: TPMPacketHeader::commandSize: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).commandCode, true)) {
            return ::futils::error::Error<>("decode: TPMPacketHeader::commandCode: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMStartup {
        std::uint16_t startupType = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMStartup::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).startupType), true)) {
            return ::futils::error::Error<>("encode: TPMStartup::startupType: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMStartup::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).startupType, true)) {
            return ::futils::error::Error<>("decode: TPMStartup::startupType: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMShutdown {
        std::uint16_t shutdownType = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMShutdown::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).shutdownType), true)) {
            return ::futils::error::Error<>("encode: TPMShutdown::shutdownType: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMShutdown::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).shutdownType, true)) {
            return ::futils::error::Error<>("decode: TPMShutdown::shutdownType: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMSelfTest {
        std::uint8_t fullTest = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    inline ::futils::error::Error<> TPMSelfTest::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).fullTest), true)) {
            return ::futils::error::Error<>("encode: TPMSelfTest::fullTest: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMSelfTest::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).fullTest, true)) {
            return ::futils::error::Error<>("decode: TPMSelfTest::fullTest: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMIncrementalSelfTest {
        std::uint32_t toTest = 0;
        std::vector<TPMAlgorithmID> algs;
        bool set_algs(auto&& v) {
            if (v.size() > ~std::uint32_t(0)) {
                return false;
            }
            (*this).toTest = v.size();
            (*this).algs = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPMIncrementalSelfTest::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).toTest), true)) {
            return ::futils::error::Error<>("encode: TPMIncrementalSelfTest::toTest: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_23_ = (*this).toTest;
        if (tmp_23_ != (*this).algs.size()) {
            return ::futils::error::Error<>("encode: TPMIncrementalSelfTest::algs: dynamic length is not compatible with its length; tmp_23_!=(*this).algs.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_24_ : (*this).algs) {
            auto tmp_25_ = static_cast<std::uint16_t>(tmp_24_);
            if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_25_), true)) {
                return ::futils::error::Error<>("encode: TPMIncrementalSelfTest::algs: write std::uint16_t failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMIncrementalSelfTest::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).toTest, true)) {
            return ::futils::error::Error<>("decode: TPMIncrementalSelfTest::toTest: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_26_ = (*this).toTest;
        (*this).algs.clear();
        for (size_t tmp_28_ = 0; tmp_28_ < tmp_26_; ++tmp_28_) {
            TPMAlgorithmID tmp_27_;
            std::uint16_t tmp_29_ = 0;
            if (!::futils::binary::read_num(r, tmp_29_, true)) {
                return ::futils::error::Error<>("decode: TPMIncrementalSelfTest::algs: read int failed", ::futils::error::Category::lib);
            }
            tmp_27_ = static_cast<TPMAlgorithmID>(tmp_29_);
            (*this).algs.push_back(std::move(tmp_27_));
        }
        return ::futils::error::Error<>();
    }
    struct TPMIncrementalSelfTestResponse {
        std::uint32_t toDo = 0;
        std::vector<TPMAlgorithmID> algs;
        bool set_algs(auto&& v) {
            if (v.size() > ~std::uint32_t(0)) {
                return false;
            }
            (*this).toDo = v.size();
            (*this).algs = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPMIncrementalSelfTestResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).toDo), true)) {
            return ::futils::error::Error<>("encode: TPMIncrementalSelfTestResponse::toDo: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_30_ = (*this).toDo;
        if (tmp_30_ != (*this).algs.size()) {
            return ::futils::error::Error<>("encode: TPMIncrementalSelfTestResponse::algs: dynamic length is not compatible with its length; tmp_30_!=(*this).algs.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_31_ : (*this).algs) {
            auto tmp_32_ = static_cast<std::uint16_t>(tmp_31_);
            if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_32_), true)) {
                return ::futils::error::Error<>("encode: TPMIncrementalSelfTestResponse::algs: write std::uint16_t failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMIncrementalSelfTestResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).toDo, true)) {
            return ::futils::error::Error<>("decode: TPMIncrementalSelfTestResponse::toDo: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_33_ = (*this).toDo;
        (*this).algs.clear();
        for (size_t tmp_35_ = 0; tmp_35_ < tmp_33_; ++tmp_35_) {
            TPMAlgorithmID tmp_34_;
            std::uint16_t tmp_36_ = 0;
            if (!::futils::binary::read_num(r, tmp_36_, true)) {
                return ::futils::error::Error<>("decode: TPMIncrementalSelfTestResponse::algs: read int failed", ::futils::error::Category::lib);
            }
            tmp_34_ = static_cast<TPMAlgorithmID>(tmp_36_);
            (*this).algs.push_back(std::move(tmp_34_));
        }
        return ::futils::error::Error<>();
    }
    struct TPMGetTestResult {
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMGetTestResult::encode(::futils::binary::writer& w) const {
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMGetTestResult::decode(::futils::binary::reader& r) {
        return ::futils::error::Error<>();
    }
    struct TPMGetCapability {
        TPMCapability capability{};
        std::uint32_t property = 0;
        std::uint32_t propertyCount = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 12;
    };
    inline ::futils::error::Error<> TPMGetCapability::encode(::futils::binary::writer& w) const {
        auto tmp_37_ = static_cast<std::uint32_t>((*this).capability);
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(tmp_37_), true)) {
            return ::futils::error::Error<>("encode: TPMGetCapability::capability: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).property), true)) {
            return ::futils::error::Error<>("encode: TPMGetCapability::property: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).propertyCount), true)) {
            return ::futils::error::Error<>("encode: TPMGetCapability::propertyCount: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMGetCapability::decode(::futils::binary::reader& r) {
        std::uint32_t tmp_38_ = 0;
        if (!::futils::binary::read_num(r, tmp_38_, true)) {
            return ::futils::error::Error<>("decode: TPMGetCapability::capability: read int failed", ::futils::error::Category::lib);
        }
        (*this).capability = static_cast<TPMCapability>(tmp_38_);
        if (!::futils::binary::read_num(r, (*this).property, true)) {
            return ::futils::error::Error<>("decode: TPMGetCapability::property: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).propertyCount, true)) {
            return ::futils::error::Error<>("decode: TPMGetCapability::propertyCount: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMGetCapabilityResponse {
        std::uint8_t moreData = 0;
        TPMCapability capability{};
        struct union_struct_41 {
            std::uint32_t handleCount = 0;
            std::vector<std::uint32_t> handle;
        };
        struct union_struct_42 {
            std::uint32_t propertyCount = 0;
            std::vector<std::uint32_t> property;
        };
        struct union_struct_43 {
            ::futils::view::rvec vender;
        };
        std::variant<std::monostate, union_struct_41, union_struct_42, union_struct_43> union_variant_40;
        std::optional<std::vector<std::uint32_t>> handle() const {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                if (!std::holds_alternative<union_struct_41>(union_variant_40)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_40).handle;
            }
            return std::nullopt;
        }
        bool handle(const std::vector<std::uint32_t>& v) {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                if (!std::holds_alternative<union_struct_41>(union_variant_40)) {
                    union_variant_40 = union_struct_41();
                }
                if (v.size() > ~std::uint32_t(0)) {
                    return false;
                }
                std::get<1>((*this).union_variant_40).handleCount = v.size();
                std::get<1>((*this).union_variant_40).handle = v;
                return true;
            }
            return false;
        }
        std::optional<std::uint32_t> handleCount() const {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                if (!std::holds_alternative<union_struct_41>(union_variant_40)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_40).handleCount;
            }
            return std::nullopt;
        }
        bool handleCount(const std::uint32_t& v) {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                if (!std::holds_alternative<union_struct_41>(union_variant_40)) {
                    union_variant_40 = union_struct_41();
                }
                std::get<1>((*this).union_variant_40).handleCount = v;
                return true;
            }
            return false;
        }
        std::optional<std::vector<std::uint32_t>> property() const {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                return std::nullopt;
            }
            if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
                if (!std::holds_alternative<union_struct_42>(union_variant_40)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_40).property;
            }
            return std::nullopt;
        }
        bool property(const std::vector<std::uint32_t>& v) {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                return false;
            }
            if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
                if (!std::holds_alternative<union_struct_42>(union_variant_40)) {
                    union_variant_40 = union_struct_42();
                }
                if (v.size() > ~std::uint32_t(0)) {
                    return false;
                }
                std::get<2>((*this).union_variant_40).propertyCount = v.size();
                std::get<2>((*this).union_variant_40).property = v;
                return true;
            }
            return false;
        }
        std::optional<std::uint32_t> propertyCount() const {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                return std::nullopt;
            }
            if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
                if (!std::holds_alternative<union_struct_42>(union_variant_40)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_40).propertyCount;
            }
            return std::nullopt;
        }
        bool propertyCount(const std::uint32_t& v) {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                return false;
            }
            if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
                if (!std::holds_alternative<union_struct_42>(union_variant_40)) {
                    union_variant_40 = union_struct_42();
                }
                std::get<2>((*this).union_variant_40).propertyCount = v;
                return true;
            }
            return false;
        }
        std::optional<::futils::view::rvec> vender() const {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                return std::nullopt;
            }
            if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
                return std::nullopt;
            }
            if (TPMCapability::TPM_CAP_VENDOR_PROPERTY == (*this).capability) {
                if (!std::holds_alternative<union_struct_43>(union_variant_40)) {
                    return std::nullopt;
                }
                return std::get<3>((*this).union_variant_40).vender;
            }
            return std::nullopt;
        }
        bool vender(const ::futils::view::rvec& v) {
            if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
                return false;
            }
            if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
                return false;
            }
            if (TPMCapability::TPM_CAP_VENDOR_PROPERTY == (*this).capability) {
                if (!std::holds_alternative<union_struct_43>(union_variant_40)) {
                    union_variant_40 = union_struct_43();
                }
                std::get<3>((*this).union_variant_40).vender = v;
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 5;
    };
    inline ::futils::error::Error<> TPMGetCapabilityResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).moreData), true)) {
            return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::moreData: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        auto tmp_44_ = static_cast<std::uint32_t>((*this).capability);
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(tmp_44_), true)) {
            return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::capability: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
            if (!std::holds_alternative<union_struct_41>(union_variant_40)) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse: union_variant_40 variant alternative union_struct_41 is not set", ::futils::error::Category::lib);
            }
            if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(std::get<1>((*this).union_variant_40).handleCount), true)) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::handleCount: write std::uint32_t failed", ::futils::error::Category::lib);
            }
            auto tmp_45_ = std::get<1>((*this).union_variant_40).handleCount;
            if (tmp_45_ != std::get<1>((*this).union_variant_40).handle.size()) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::handle: dynamic length is not compatible with its length; tmp_45_!=std::get<1>((*this).union_variant_40).handle.size()", ::futils::error::Category::lib);
            }
            for (auto& tmp_46_ : std::get<1>((*this).union_variant_40).handle) {
                if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(tmp_46_), true)) {
                    return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::handle: write std::uint32_t failed", ::futils::error::Category::lib);
                }
            }
        }
        else if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
            if (!std::holds_alternative<union_struct_42>(union_variant_40)) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse: union_variant_40 variant alternative union_struct_42 is not set", ::futils::error::Category::lib);
            }
            if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(std::get<2>((*this).union_variant_40).propertyCount), true)) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::propertyCount: write std::uint32_t failed", ::futils::error::Category::lib);
            }
            auto tmp_47_ = std::get<2>((*this).union_variant_40).propertyCount;
            if (tmp_47_ != std::get<2>((*this).union_variant_40).property.size()) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::property: dynamic length is not compatible with its length; tmp_47_!=std::get<2>((*this).union_variant_40).property.size()", ::futils::error::Category::lib);
            }
            for (auto& tmp_48_ : std::get<2>((*this).union_variant_40).property) {
                if (!::futils::binary::write_num(w, static_cast<std::uint32_t>(tmp_48_), true)) {
                    return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::property: write std::uint32_t failed", ::futils::error::Category::lib);
                }
            }
        }
        else if (TPMCapability::TPM_CAP_VENDOR_PROPERTY == (*this).capability) {
            if (!std::holds_alternative<union_struct_43>(union_variant_40)) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse: union_variant_40 variant alternative union_struct_43 is not set", ::futils::error::Category::lib);
            }
            if (!w.write(std::get<3>((*this).union_variant_40).vender)) {
                return ::futils::error::Error<>("encode: TPMGetCapabilityResponse::vender: write array failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMGetCapabilityResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).moreData, true)) {
            return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::moreData: read int failed", ::futils::error::Category::lib);
        }
        std::uint32_t tmp_49_ = 0;
        if (!::futils::binary::read_num(r, tmp_49_, true)) {
            return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::capability: read int failed", ::futils::error::Category::lib);
        }
        (*this).capability = static_cast<TPMCapability>(tmp_49_);
        if (TPMCapability::TPM_CAP_HANDLES == (*this).capability) {
            if (!std::holds_alternative<union_struct_41>(union_variant_40)) {
                union_variant_40 = union_struct_41();
            }
            if (!::futils::binary::read_num(r, std::get<1>((*this).union_variant_40).handleCount, true)) {
                return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::handleCount: read int failed", ::futils::error::Category::lib);
            }
            auto tmp_50_ = std::get<1>((*this).union_variant_40).handleCount;
            std::get<1>((*this).union_variant_40).handle.clear();
            for (size_t tmp_52_ = 0; tmp_52_ < tmp_50_; ++tmp_52_) {
                std::uint32_t tmp_51_;
                if (!::futils::binary::read_num(r, tmp_51_, true)) {
                    return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::handle: read int failed", ::futils::error::Category::lib);
                }
                std::get<1>((*this).union_variant_40).handle.push_back(std::move(tmp_51_));
            }
        }
        else if (TPMCapability::TPM_CAP_TPM_PROPERTIES == (*this).capability) {
            if (!std::holds_alternative<union_struct_42>(union_variant_40)) {
                union_variant_40 = union_struct_42();
            }
            if (!::futils::binary::read_num(r, std::get<2>((*this).union_variant_40).propertyCount, true)) {
                return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::propertyCount: read int failed", ::futils::error::Category::lib);
            }
            auto tmp_53_ = std::get<2>((*this).union_variant_40).propertyCount;
            std::get<2>((*this).union_variant_40).property.clear();
            for (size_t tmp_55_ = 0; tmp_55_ < tmp_53_; ++tmp_55_) {
                std::uint32_t tmp_54_;
                if (!::futils::binary::read_num(r, tmp_54_, true)) {
                    return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::property: read int failed", ::futils::error::Category::lib);
                }
                std::get<2>((*this).union_variant_40).property.push_back(std::move(tmp_54_));
            }
        }
        else if (TPMCapability::TPM_CAP_VENDOR_PROPERTY == (*this).capability) {
            if (!std::holds_alternative<union_struct_43>(union_variant_40)) {
                union_variant_40 = union_struct_43();
            }
            if (!r.read_until_eof(std::get<3>((*this).union_variant_40).vender)) {
                return ::futils::error::Error<>("decode: TPMGetCapabilityResponse::vender: read byte array failed", ::futils::error::Category::lib);
            }
        }
        return ::futils::error::Error<>();
    }
    struct TPMGetRandom {
        std::uint16_t bytesRequested = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMGetRandom::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).bytesRequested), true)) {
            return ::futils::error::Error<>("encode: TPMGetRandom::bytesRequested: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMGetRandom::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).bytesRequested, true)) {
            return ::futils::error::Error<>("decode: TPMGetRandom::bytesRequested: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2FlushContext {
        std::uint32_t handle = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2FlushContext::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).handle), true)) {
            return ::futils::error::Error<>("encode: TPM2FlushContext::handle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2FlushContext::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).handle, true)) {
            return ::futils::error::Error<>("decode: TPM2FlushContext::handle: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2PolicyRestart {
        std::uint32_t sessionHandle = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2PolicyRestart::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).sessionHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2PolicyRestart::sessionHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2PolicyRestart::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).sessionHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2PolicyRestart::sessionHandle: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ReadPublic {
        std::uint32_t objectHandle = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ReadPublic::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ReadPublic::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ReadPublic::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ReadPublic::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ECCParameters {
        std::uint16_t curveID = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPM2ECCParameters::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).curveID), true)) {
            return ::futils::error::Error<>("encode: TPM2ECCParameters::curveID: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ECCParameters::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).curveID, true)) {
            return ::futils::error::Error<>("decode: TPM2ECCParameters::curveID: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2HMACStartResponse {
        std::uint32_t handle = 0;
        std::uint32_t paramSize = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2HMACStartResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).handle), true)) {
            return ::futils::error::Error<>("encode: TPM2HMACStartResponse::handle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2HMACStartResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HMACStartResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).handle, true)) {
            return ::futils::error::Error<>("decode: TPM2HMACStartResponse::handle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2HMACStartResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2HashSequenceStartResponse {
        std::uint32_t handle = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2HashSequenceStartResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).handle), true)) {
            return ::futils::error::Error<>("encode: TPM2HashSequenceStartResponse::handle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HashSequenceStartResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).handle, true)) {
            return ::futils::error::Error<>("decode: TPM2HashSequenceStartResponse::handle: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct AuthCommand {
        struct union_struct_58 {
        };
        std::variant<std::monostate, union_struct_58> union_variant_57;
        std::uint32_t sessionHandle = 0;
        Bytes16 nonce;
        std::uint8_t sessionAttributes = 0;
        Bytes16 hmac;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
    };
    inline ::futils::error::Error<> AuthCommand::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!session_state.hasSession) {
            return ::futils::error::Error<>();
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).sessionHandle), true)) {
            return ::futils::error::Error<>("encode: AuthCommand::sessionHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nonce.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).sessionAttributes), true)) {
            return ::futils::error::Error<>("encode: AuthCommand::sessionAttributes: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).hmac.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> AuthCommand::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!session_state.hasSession) {
            if (!std::holds_alternative<union_struct_58>(union_variant_57)) {
                union_variant_57 = union_struct_58();
            }
            return ::futils::error::Error<>();
        }
        if (!::futils::binary::read_num(r, (*this).sessionHandle, true)) {
            return ::futils::error::Error<>("decode: AuthCommand::sessionHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nonce.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).sessionAttributes, true)) {
            return ::futils::error::Error<>("decode: AuthCommand::sessionAttributes: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).hmac.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct AuthResponse {
        Bytes16 nonce;
        std::uint8_t sessionAttributes = 0;
        Bytes16 hmac;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> AuthResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).nonce.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).sessionAttributes), true)) {
            return ::futils::error::Error<>("encode: AuthResponse::sessionAttributes: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).hmac.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> AuthResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).nonce.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).sessionAttributes, true)) {
            return ::futils::error::Error<>("decode: AuthResponse::sessionAttributes: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).hmac.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct PCREntry {
        std::uint16_t hash = 0;
        Bytes8 select;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> PCREntry::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).hash), true)) {
            return ::futils::error::Error<>("encode: PCREntry::hash: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).select.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PCREntry::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).hash, true)) {
            return ::futils::error::Error<>("decode: PCREntry::hash: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).select.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct PCR {
        std::uint32_t count = 0;
        std::vector<PCREntry> pcrs;
        bool set_pcrs(auto&& v) {
            if (v.size() > ~std::uint32_t(0)) {
                return false;
            }
            (*this).count = v.size();
            (*this).pcrs = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> PCR::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).count), true)) {
            return ::futils::error::Error<>("encode: PCR::count: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_59_ = (*this).count;
        if (tmp_59_ != (*this).pcrs.size()) {
            return ::futils::error::Error<>("encode: PCR::pcrs: dynamic length is not compatible with its length; tmp_59_!=(*this).pcrs.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_60_ : (*this).pcrs) {
            if (auto err = tmp_60_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PCR::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).count, true)) {
            return ::futils::error::Error<>("decode: PCR::count: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_61_ = (*this).count;
        (*this).pcrs.clear();
        for (size_t tmp_63_ = 0; tmp_63_ < tmp_61_; ++tmp_63_) {
            PCREntry tmp_62_;
            if (auto err = tmp_62_.decode(r)) {
                return err;
            }
            (*this).pcrs.push_back(std::move(tmp_62_));
        }
        return ::futils::error::Error<>();
    }
    struct ECCPoint {
        Bytes16 x;
        Bytes16 y;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> ECCPoint::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).x.encode(w)) {
            return err;
        }
        if (auto err = (*this).y.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> ECCPoint::decode(::futils::binary::reader& r) {
        if (auto err = (*this).x.decode(r)) {
            return err;
        }
        if (auto err = (*this).y.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMECCPoint {
        std::uint16_t size = 0;
        ECCPoint point;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMECCPoint::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).size), true)) {
            return ::futils::error::Error<>("encode: TPMECCPoint::size: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).point.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMECCPoint::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).size, true)) {
            return ::futils::error::Error<>("decode: TPMECCPoint::size: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).point.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct SensitiveData {
        std::uint16_t sensitiveType = 0;
        Bytes16 authValue;
        Bytes16 seedValue;
        Bytes16 sensitiveData;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> SensitiveData::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).sensitiveType), true)) {
            return ::futils::error::Error<>("encode: SensitiveData::sensitiveType: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authValue.encode(w)) {
            return err;
        }
        if (auto err = (*this).seedValue.encode(w)) {
            return err;
        }
        if (auto err = (*this).sensitiveData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> SensitiveData::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).sensitiveType, true)) {
            return ::futils::error::Error<>("decode: SensitiveData::sensitiveType: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authValue.decode(r)) {
            return err;
        }
        if (auto err = (*this).seedValue.decode(r)) {
            return err;
        }
        if (auto err = (*this).sensitiveData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMSensitive {
        std::uint16_t size = 0;
        SensitiveData sensitive;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMSensitive::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).size), true)) {
            return ::futils::error::Error<>("encode: TPMSensitive::size: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sensitive.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMSensitive::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).size, true)) {
            return ::futils::error::Error<>("decode: TPMSensitive::size: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sensitive.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct SensitiveCreate {
        Bytes16 userAuth;
        Bytes16 sensitiveData;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> SensitiveCreate::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).userAuth.encode(w)) {
            return err;
        }
        if (auto err = (*this).sensitiveData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> SensitiveCreate::decode(::futils::binary::reader& r) {
        if (auto err = (*this).userAuth.decode(r)) {
            return err;
        }
        if (auto err = (*this).sensitiveData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMSensitiveCreate {
        std::uint16_t size = 0;
        SensitiveCreate sensitive;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMSensitiveCreate::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).size), true)) {
            return ::futils::error::Error<>("encode: TPMSensitiveCreate::size: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sensitive.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMSensitiveCreate::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).size, true)) {
            return ::futils::error::Error<>("decode: TPMSensitiveCreate::size: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sensitive.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct PublicParamsKeyedHash {
        TPMScheme scheme;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> PublicParamsKeyedHash::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).scheme.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PublicParamsKeyedHash::decode(::futils::binary::reader& r) {
        if (auto err = (*this).scheme.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMSymetric {
        TPMAlgorithmID alg{};
        struct union_struct_66 {
            TPMSymetricXor symmetric_xor;
        };
        struct union_struct_67 {
            TPMSymetricCrypto symmetric_crypto;
        };
        std::variant<std::monostate, union_struct_66, union_struct_67> union_variant_65;
        std::optional<TPMSymetricCrypto> symmetric_crypto() const {
            if (TPMAlgorithmID::TPM_ALG_XOR == (*this).alg) {
                return std::nullopt;
            }
            if (!std::holds_alternative<union_struct_67>(union_variant_65)) {
                return std::nullopt;
            }
            return std::get<2>((*this).union_variant_65).symmetric_crypto;
        }
        bool symmetric_crypto(const TPMSymetricCrypto& v) {
            if (TPMAlgorithmID::TPM_ALG_XOR == (*this).alg) {
                return false;
            }
            if (!std::holds_alternative<union_struct_67>(union_variant_65)) {
                union_variant_65 = union_struct_67();
            }
            std::get<2>((*this).union_variant_65).symmetric_crypto = v;
            return true;
        }
        std::optional<TPMSymetricXor> symmetric_xor() const {
            if (TPMAlgorithmID::TPM_ALG_XOR == (*this).alg) {
                if (!std::holds_alternative<union_struct_66>(union_variant_65)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_65).symmetric_xor;
            }
            return std::nullopt;
        }
        bool symmetric_xor(const TPMSymetricXor& v) {
            if (TPMAlgorithmID::TPM_ALG_XOR == (*this).alg) {
                if (!std::holds_alternative<union_struct_66>(union_variant_65)) {
                    union_variant_65 = union_struct_66();
                }
                std::get<1>((*this).union_variant_65).symmetric_xor = v;
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMSymetric::encode(::futils::binary::writer& w) const {
        auto tmp_68_ = static_cast<std::uint16_t>((*this).alg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_68_), true)) {
            return ::futils::error::Error<>("encode: TPMSymetric::alg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (TPMAlgorithmID::TPM_ALG_XOR == (*this).alg) {
            if (!std::holds_alternative<union_struct_66>(union_variant_65)) {
                return ::futils::error::Error<>("encode: TPMSymetric: union_variant_65 variant alternative union_struct_66 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<1>((*this).union_variant_65).symmetric_xor.encode(w)) {
                return err;
            }
        }
        else {
            if (!std::holds_alternative<union_struct_67>(union_variant_65)) {
                return ::futils::error::Error<>("encode: TPMSymetric: union_variant_65 variant alternative union_struct_67 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<2>((*this).union_variant_65).symmetric_crypto.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMSymetric::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_69_ = 0;
        if (!::futils::binary::read_num(r, tmp_69_, true)) {
            return ::futils::error::Error<>("decode: TPMSymetric::alg: read int failed", ::futils::error::Category::lib);
        }
        (*this).alg = static_cast<TPMAlgorithmID>(tmp_69_);
        if (TPMAlgorithmID::TPM_ALG_XOR == (*this).alg) {
            if (!std::holds_alternative<union_struct_66>(union_variant_65)) {
                union_variant_65 = union_struct_66();
            }
            if (auto err = std::get<1>((*this).union_variant_65).symmetric_xor.decode(r)) {
                return err;
            }
        }
        else {
            if (!std::holds_alternative<union_struct_67>(union_variant_65)) {
                union_variant_65 = union_struct_67();
            }
            if (auto err = std::get<2>((*this).union_variant_65).symmetric_crypto.decode(r)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    struct PublicParamsRSA {
        TPMSymetric symmetric;
        TPMScheme scheme;
        std::uint16_t keyBits = 0;
        std::uint32_t exponent = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> PublicParamsRSA::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).symmetric.encode(w)) {
            return err;
        }
        if (auto err = (*this).scheme.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).keyBits), true)) {
            return ::futils::error::Error<>("encode: PublicParamsRSA::keyBits: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).exponent), true)) {
            return ::futils::error::Error<>("encode: PublicParamsRSA::exponent: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PublicParamsRSA::decode(::futils::binary::reader& r) {
        if (auto err = (*this).symmetric.decode(r)) {
            return err;
        }
        if (auto err = (*this).scheme.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).keyBits, true)) {
            return ::futils::error::Error<>("decode: PublicParamsRSA::keyBits: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).exponent, true)) {
            return ::futils::error::Error<>("decode: PublicParamsRSA::exponent: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct PublicParamsOther {
        TPMSymetric symmetric;
        TPMScheme scheme;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> PublicParamsOther::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).symmetric.encode(w)) {
            return err;
        }
        if (auto err = (*this).scheme.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PublicParamsOther::decode(::futils::binary::reader& r) {
        if (auto err = (*this).symmetric.decode(r)) {
            return err;
        }
        if (auto err = (*this).scheme.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct PublicParamsECC {
        TPMSymetric symmetric;
        TPMScheme scheme;
        std::uint16_t curveID = 0;
        TPMScheme kdf;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> PublicParamsECC::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).symmetric.encode(w)) {
            return err;
        }
        if (auto err = (*this).scheme.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).curveID), true)) {
            return ::futils::error::Error<>("encode: PublicParamsECC::curveID: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).kdf.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PublicParamsECC::decode(::futils::binary::reader& r) {
        if (auto err = (*this).symmetric.decode(r)) {
            return err;
        }
        if (auto err = (*this).scheme.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).curveID, true)) {
            return ::futils::error::Error<>("decode: PublicParamsECC::curveID: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).kdf.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct PublicKeyArea {
        TPMAlgorithmID type{};
        TPMAlgorithmID nameAlg{};
        std::uint32_t objectAttributes = 0;
        Bytes16 authPolicy;
        struct union_struct_72 {
            PublicParamsRSA rsa_params;
            Bytes16 rsa;
        };
        struct union_struct_73 {
            PublicParamsECC ecc_params;
            ECCPoint ecc_point;
        };
        struct union_struct_74 {
            PublicParamsKeyedHash keyedhash_params;
            Bytes16 keyedhash;
        };
        struct union_struct_75 {
            PublicParamSymCipher symcipher_params;
            Bytes16 sym;
        };
        struct union_struct_76 {
            PublicParamsOther other_params;
        };
        std::variant<std::monostate, union_struct_72, union_struct_73, union_struct_74, union_struct_75, union_struct_76> union_variant_71;
        std::optional<PublicParamsECC> ecc_params() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                if (!std::holds_alternative<union_struct_73>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_71).ecc_params;
            }
            return std::nullopt;
        }
        bool ecc_params(const PublicParamsECC& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                if (!std::holds_alternative<union_struct_73>(union_variant_71)) {
                    union_variant_71 = union_struct_73();
                }
                std::get<2>((*this).union_variant_71).ecc_params = v;
                return true;
            }
            return false;
        }
        std::optional<ECCPoint> ecc_point() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                if (!std::holds_alternative<union_struct_73>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_71).ecc_point;
            }
            return std::nullopt;
        }
        bool ecc_point(const ECCPoint& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                if (!std::holds_alternative<union_struct_73>(union_variant_71)) {
                    union_variant_71 = union_struct_73();
                }
                std::get<2>((*this).union_variant_71).ecc_point = v;
                return true;
            }
            return false;
        }
        std::optional<Bytes16> keyedhash() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                if (!std::holds_alternative<union_struct_74>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<3>((*this).union_variant_71).keyedhash;
            }
            return std::nullopt;
        }
        bool keyedhash(const Bytes16& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                if (!std::holds_alternative<union_struct_74>(union_variant_71)) {
                    union_variant_71 = union_struct_74();
                }
                std::get<3>((*this).union_variant_71).keyedhash = v;
                return true;
            }
            return false;
        }
        std::optional<PublicParamsKeyedHash> keyedhash_params() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                if (!std::holds_alternative<union_struct_74>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<3>((*this).union_variant_71).keyedhash_params;
            }
            return std::nullopt;
        }
        bool keyedhash_params(const PublicParamsKeyedHash& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                if (!std::holds_alternative<union_struct_74>(union_variant_71)) {
                    union_variant_71 = union_struct_74();
                }
                std::get<3>((*this).union_variant_71).keyedhash_params = v;
                return true;
            }
            return false;
        }
        std::optional<PublicParamsOther> other_params() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
                return std::nullopt;
            }
            if (!std::holds_alternative<union_struct_76>(union_variant_71)) {
                return std::nullopt;
            }
            return std::get<5>((*this).union_variant_71).other_params;
        }
        bool other_params(const PublicParamsOther& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
                return false;
            }
            if (!std::holds_alternative<union_struct_76>(union_variant_71)) {
                union_variant_71 = union_struct_76();
            }
            std::get<5>((*this).union_variant_71).other_params = v;
            return true;
        }
        std::optional<Bytes16> rsa() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                if (!std::holds_alternative<union_struct_72>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_71).rsa;
            }
            return std::nullopt;
        }
        bool rsa(const Bytes16& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                if (!std::holds_alternative<union_struct_72>(union_variant_71)) {
                    union_variant_71 = union_struct_72();
                }
                std::get<1>((*this).union_variant_71).rsa = v;
                return true;
            }
            return false;
        }
        std::optional<PublicParamsRSA> rsa_params() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                if (!std::holds_alternative<union_struct_72>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_71).rsa_params;
            }
            return std::nullopt;
        }
        bool rsa_params(const PublicParamsRSA& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                if (!std::holds_alternative<union_struct_72>(union_variant_71)) {
                    union_variant_71 = union_struct_72();
                }
                std::get<1>((*this).union_variant_71).rsa_params = v;
                return true;
            }
            return false;
        }
        std::optional<Bytes16> sym() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
                if (!std::holds_alternative<union_struct_75>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<4>((*this).union_variant_71).sym;
            }
            return std::nullopt;
        }
        bool sym(const Bytes16& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
                if (!std::holds_alternative<union_struct_75>(union_variant_71)) {
                    union_variant_71 = union_struct_75();
                }
                std::get<4>((*this).union_variant_71).sym = v;
                return true;
            }
            return false;
        }
        std::optional<PublicParamSymCipher> symcipher_params() const {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
                if (!std::holds_alternative<union_struct_75>(union_variant_71)) {
                    return std::nullopt;
                }
                return std::get<4>((*this).union_variant_71).symcipher_params;
            }
            return std::nullopt;
        }
        bool symcipher_params(const PublicParamSymCipher& v) {
            if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
                if (!std::holds_alternative<union_struct_75>(union_variant_71)) {
                    union_variant_71 = union_struct_75();
                }
                std::get<4>((*this).union_variant_71).symcipher_params = v;
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> PublicKeyArea::encode(::futils::binary::writer& w) const {
        auto tmp_77_ = static_cast<std::uint16_t>((*this).type);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_77_), true)) {
            return ::futils::error::Error<>("encode: PublicKeyArea::type: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_78_ = static_cast<std::uint16_t>((*this).nameAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_78_), true)) {
            return ::futils::error::Error<>("encode: PublicKeyArea::nameAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectAttributes), true)) {
            return ::futils::error::Error<>("encode: PublicKeyArea::objectAttributes: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authPolicy.encode(w)) {
            return err;
        }
        if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
            if (!std::holds_alternative<union_struct_72>(union_variant_71)) {
                return ::futils::error::Error<>("encode: PublicKeyArea: union_variant_71 variant alternative union_struct_72 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<1>((*this).union_variant_71).rsa_params.encode(w)) {
                return err;
            }
            if (auto err = std::get<1>((*this).union_variant_71).rsa.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
            if (!std::holds_alternative<union_struct_73>(union_variant_71)) {
                return ::futils::error::Error<>("encode: PublicKeyArea: union_variant_71 variant alternative union_struct_73 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<2>((*this).union_variant_71).ecc_params.encode(w)) {
                return err;
            }
            if (auto err = std::get<2>((*this).union_variant_71).ecc_point.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
            if (!std::holds_alternative<union_struct_74>(union_variant_71)) {
                return ::futils::error::Error<>("encode: PublicKeyArea: union_variant_71 variant alternative union_struct_74 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<3>((*this).union_variant_71).keyedhash_params.encode(w)) {
                return err;
            }
            if (auto err = std::get<3>((*this).union_variant_71).keyedhash.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
            if (!std::holds_alternative<union_struct_75>(union_variant_71)) {
                return ::futils::error::Error<>("encode: PublicKeyArea: union_variant_71 variant alternative union_struct_75 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<4>((*this).union_variant_71).symcipher_params.encode(w)) {
                return err;
            }
            if (auto err = std::get<4>((*this).union_variant_71).sym.encode(w)) {
                return err;
            }
        }
        else {
            if (!std::holds_alternative<union_struct_76>(union_variant_71)) {
                return ::futils::error::Error<>("encode: PublicKeyArea: union_variant_71 variant alternative union_struct_76 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<5>((*this).union_variant_71).other_params.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> PublicKeyArea::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_79_ = 0;
        if (!::futils::binary::read_num(r, tmp_79_, true)) {
            return ::futils::error::Error<>("decode: PublicKeyArea::type: read int failed", ::futils::error::Category::lib);
        }
        (*this).type = static_cast<TPMAlgorithmID>(tmp_79_);
        std::uint16_t tmp_80_ = 0;
        if (!::futils::binary::read_num(r, tmp_80_, true)) {
            return ::futils::error::Error<>("decode: PublicKeyArea::nameAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).nameAlg = static_cast<TPMAlgorithmID>(tmp_80_);
        if (!::futils::binary::read_num(r, (*this).objectAttributes, true)) {
            return ::futils::error::Error<>("decode: PublicKeyArea::objectAttributes: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authPolicy.decode(r)) {
            return err;
        }
        if (TPMAlgorithmID::TPM_ALG_RSA == (*this).type) {
            if (!std::holds_alternative<union_struct_72>(union_variant_71)) {
                union_variant_71 = union_struct_72();
            }
            if (auto err = std::get<1>((*this).union_variant_71).rsa_params.decode(r)) {
                return err;
            }
            if (auto err = std::get<1>((*this).union_variant_71).rsa.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_ECC == (*this).type) {
            if (!std::holds_alternative<union_struct_73>(union_variant_71)) {
                union_variant_71 = union_struct_73();
            }
            if (auto err = std::get<2>((*this).union_variant_71).ecc_params.decode(r)) {
                return err;
            }
            if (auto err = std::get<2>((*this).union_variant_71).ecc_point.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_KEYEDHASH == (*this).type) {
            if (!std::holds_alternative<union_struct_74>(union_variant_71)) {
                union_variant_71 = union_struct_74();
            }
            if (auto err = std::get<3>((*this).union_variant_71).keyedhash_params.decode(r)) {
                return err;
            }
            if (auto err = std::get<3>((*this).union_variant_71).keyedhash.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_SYMCIPHER == (*this).type) {
            if (!std::holds_alternative<union_struct_75>(union_variant_71)) {
                union_variant_71 = union_struct_75();
            }
            if (auto err = std::get<4>((*this).union_variant_71).symcipher_params.decode(r)) {
                return err;
            }
            if (auto err = std::get<4>((*this).union_variant_71).sym.decode(r)) {
                return err;
            }
        }
        else {
            if (!std::holds_alternative<union_struct_76>(union_variant_71)) {
                union_variant_71 = union_struct_76();
            }
            if (auto err = std::get<5>((*this).union_variant_71).other_params.decode(r)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    struct TPMPublicKey {
        std::uint16_t size = 0;
        PublicKeyArea public_key_area;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> TPMPublicKey::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).size), true)) {
            return ::futils::error::Error<>("encode: TPMPublicKey::size: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).public_key_area.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMPublicKey::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).size, true)) {
            return ::futils::error::Error<>("decode: TPMPublicKey::size: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).public_key_area.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct SignatureECDSA {
        TPMAlgorithmID hash{};
        Bytes16 r;
        Bytes16 s;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> SignatureECDSA::encode(::futils::binary::writer& w) const {
        auto tmp_81_ = static_cast<std::uint16_t>((*this).hash);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_81_), true)) {
            return ::futils::error::Error<>("encode: SignatureECDSA::hash: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).r.encode(w)) {
            return err;
        }
        if (auto err = (*this).s.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> SignatureECDSA::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_82_ = 0;
        if (!::futils::binary::read_num(r, tmp_82_, true)) {
            return ::futils::error::Error<>("decode: SignatureECDSA::hash: read int failed", ::futils::error::Category::lib);
        }
        (*this).hash = static_cast<TPMAlgorithmID>(tmp_82_);
        if (auto err = (*this).r.decode(r)) {
            return err;
        }
        if (auto err = (*this).s.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct SignatureRSA {
        TPMAlgorithmID hash{};
        Bytes16 sig;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> SignatureRSA::encode(::futils::binary::writer& w) const {
        auto tmp_83_ = static_cast<std::uint16_t>((*this).hash);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_83_), true)) {
            return ::futils::error::Error<>("encode: SignatureRSA::hash: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sig.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> SignatureRSA::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_84_ = 0;
        if (!::futils::binary::read_num(r, tmp_84_, true)) {
            return ::futils::error::Error<>("decode: SignatureRSA::hash: read int failed", ::futils::error::Category::lib);
        }
        (*this).hash = static_cast<TPMAlgorithmID>(tmp_84_);
        if (auto err = (*this).sig.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestCerify {
        Bytes16 name;
        Bytes16 qualifiedName;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMAttestCerify::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        if (auto err = (*this).qualifiedName.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestCerify::decode(::futils::binary::reader& r) {
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        if (auto err = (*this).qualifiedName.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestCreation {
        Bytes16 name;
        Bytes16 creationHash;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMAttestCreation::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        if (auto err = (*this).creationHash.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestCreation::decode(::futils::binary::reader& r) {
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        if (auto err = (*this).creationHash.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestCommandAudit {
        std::uint64_t auditCounter = 0;
        TPMAlgorithmID digestAlg{};
        Bytes16 auditDigest;
        Bytes16 commendDigest;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 10;
    };
    inline ::futils::error::Error<> TPMAttestCommandAudit::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).auditCounter), true)) {
            return ::futils::error::Error<>("encode: TPMAttestCommandAudit::auditCounter: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        auto tmp_85_ = static_cast<std::uint16_t>((*this).digestAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_85_), true)) {
            return ::futils::error::Error<>("encode: TPMAttestCommandAudit::digestAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auditDigest.encode(w)) {
            return err;
        }
        if (auto err = (*this).commendDigest.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestCommandAudit::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).auditCounter, true)) {
            return ::futils::error::Error<>("decode: TPMAttestCommandAudit::auditCounter: read int failed", ::futils::error::Category::lib);
        }
        std::uint16_t tmp_86_ = 0;
        if (!::futils::binary::read_num(r, tmp_86_, true)) {
            return ::futils::error::Error<>("decode: TPMAttestCommandAudit::digestAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).digestAlg = static_cast<TPMAlgorithmID>(tmp_86_);
        if (auto err = (*this).auditDigest.decode(r)) {
            return err;
        }
        if (auto err = (*this).commendDigest.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestSessionAudit {
        std::uint8_t exclusiveSession = 0;
        Bytes16 sessionDigest;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 1;
    };
    inline ::futils::error::Error<> TPMAttestSessionAudit::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).exclusiveSession), true)) {
            return ::futils::error::Error<>("encode: TPMAttestSessionAudit::exclusiveSession: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sessionDigest.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestSessionAudit::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).exclusiveSession, true)) {
            return ::futils::error::Error<>("decode: TPMAttestSessionAudit::exclusiveSession: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).sessionDigest.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestTime {
        ClockInfo clock_info;
        std::uint64_t firmware_version = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 25;
    };
    inline ::futils::error::Error<> TPMAttestTime::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).clock_info.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).firmware_version), true)) {
            return ::futils::error::Error<>("encode: TPMAttestTime::firmware_version: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestTime::decode(::futils::binary::reader& r) {
        if (auto err = (*this).clock_info.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).firmware_version, true)) {
            return ::futils::error::Error<>("decode: TPMAttestTime::firmware_version: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestNV {
        Bytes16 indexName;
        std::uint16_t offset = 0;
        Bytes16 nvContents;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMAttestNV::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).indexName.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).offset), true)) {
            return ::futils::error::Error<>("encode: TPMAttestNV::offset: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nvContents.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestNV::decode(::futils::binary::reader& r) {
        if (auto err = (*this).indexName.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).offset, true)) {
            return ::futils::error::Error<>("decode: TPMAttestNV::offset: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nvContents.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMPublicNVMarshaled {
        std::uint32_t index = 0;
        TPMAlgorithmID nameAlg{};
        std::uint32_t attributes = 0;
        Bytes16 authPolicy;
        std::uint16_t dataSize = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 10;
    };
    inline ::futils::error::Error<> TPMPublicNVMarshaled::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).index), true)) {
            return ::futils::error::Error<>("encode: TPMPublicNVMarshaled::index: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_87_ = static_cast<std::uint16_t>((*this).nameAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_87_), true)) {
            return ::futils::error::Error<>("encode: TPMPublicNVMarshaled::nameAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).attributes), true)) {
            return ::futils::error::Error<>("encode: TPMPublicNVMarshaled::attributes: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authPolicy.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).dataSize), true)) {
            return ::futils::error::Error<>("encode: TPMPublicNVMarshaled::dataSize: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMPublicNVMarshaled::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).index, true)) {
            return ::futils::error::Error<>("decode: TPMPublicNVMarshaled::index: read int failed", ::futils::error::Category::lib);
        }
        std::uint16_t tmp_88_ = 0;
        if (!::futils::binary::read_num(r, tmp_88_, true)) {
            return ::futils::error::Error<>("decode: TPMPublicNVMarshaled::nameAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).nameAlg = static_cast<TPMAlgorithmID>(tmp_88_);
        if (!::futils::binary::read_num(r, (*this).attributes, true)) {
            return ::futils::error::Error<>("decode: TPMPublicNVMarshaled::attributes: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authPolicy.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).dataSize, true)) {
            return ::futils::error::Error<>("decode: TPMPublicNVMarshaled::dataSize: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMGetTestResultResponse {
        Bytes16 outData;
        std::uint16_t testResult = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMGetTestResultResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).outData.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).testResult), true)) {
            return ::futils::error::Error<>("encode: TPMGetTestResultResponse::testResult: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMGetTestResultResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).outData.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).testResult, true)) {
            return ::futils::error::Error<>("decode: TPMGetTestResultResponse::testResult: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMGetRandomResponse {
        Bytes16 randomBytes;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMGetRandomResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).randomBytes.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMGetRandomResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).randomBytes.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2StirRandom {
        Bytes16 entropy;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2StirRandom::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).entropy.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2StirRandom::decode(::futils::binary::reader& r) {
        if (auto err = (*this).entropy.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2PCRRead {
        PCR pcr;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2PCRRead::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).pcr.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2PCRRead::decode(::futils::binary::reader& r) {
        if (auto err = (*this).pcr.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct CreationTicket {
        std::uint16_t tag = 0;
        std::uint32_t hierarchy = 0;
        Bytes16 digest;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 6;
    };
    inline ::futils::error::Error<> CreationTicket::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).tag), true)) {
            return ::futils::error::Error<>("encode: CreationTicket::tag: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).hierarchy), true)) {
            return ::futils::error::Error<>("encode: CreationTicket::hierarchy: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).digest.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> CreationTicket::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).tag, true)) {
            return ::futils::error::Error<>("decode: CreationTicket::tag: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).hierarchy, true)) {
            return ::futils::error::Error<>("decode: CreationTicket::hierarchy: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).digest.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CreateResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outPrivate;
        TPMPublicKey outPublic;
        std::uint16_t creationDataSize = 0;
        PCR pcrSelect;
        Bytes16 pcrDigest;
        std::uint8_t locality = 0;
        TPMAlgorithmID parentNameAlg{};
        Bytes16 parentName;
        Bytes16 parentQualifiedName;
        Bytes16 outsideInfo;
        Bytes16 creationHash;
        CreationTicket creationTicket;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2CreateResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.encode(w)) {
            return err;
        }
        if (auto err = (*this).outPublic.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).creationDataSize), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateResponse::creationDataSize: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).pcrSelect.encode(w)) {
            return err;
        }
        if (auto err = (*this).pcrDigest.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).locality), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateResponse::locality: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        auto tmp_89_ = static_cast<std::uint16_t>((*this).parentNameAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_89_), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateResponse::parentNameAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).parentName.encode(w)) {
            return err;
        }
        if (auto err = (*this).parentQualifiedName.encode(w)) {
            return err;
        }
        if (auto err = (*this).outsideInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).creationHash.encode(w)) {
            return err;
        }
        if (auto err = (*this).creationTicket.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CreateResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.decode(r)) {
            return err;
        }
        if (auto err = (*this).outPublic.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).creationDataSize, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateResponse::creationDataSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).pcrSelect.decode(r)) {
            return err;
        }
        if (auto err = (*this).pcrDigest.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).locality, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateResponse::locality: read int failed", ::futils::error::Category::lib);
        }
        std::uint16_t tmp_90_ = 0;
        if (!::futils::binary::read_num(r, tmp_90_, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateResponse::parentNameAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).parentNameAlg = static_cast<TPMAlgorithmID>(tmp_90_);
        if (auto err = (*this).parentName.decode(r)) {
            return err;
        }
        if (auto err = (*this).parentQualifiedName.decode(r)) {
            return err;
        }
        if (auto err = (*this).outsideInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).creationHash.decode(r)) {
            return err;
        }
        if (auto err = (*this).creationTicket.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CreatePrimaryResponse {
        TPM2CreateResponse created;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2CreatePrimaryResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).created.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CreatePrimaryResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).created.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2LoadResponse {
        std::uint32_t objectHandle = 0;
        std::uint32_t paramSize = 0;
        Bytes16 name;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2LoadResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadResponse::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2LoadResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadResponse::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Unseal {
        std::uint32_t itemHandle = 0;
        AuthCommand auth;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Unseal::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).itemHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Unseal::itemHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Unseal::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).itemHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Unseal::itemHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2UnsealResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outData;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2UnsealResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2UnsealResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2UnsealResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2UnsealResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2StartAuthSessionResponse {
        std::uint32_t handle = 0;
        Bytes16 nonceTPM;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2StartAuthSessionResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).handle), true)) {
            return ::futils::error::Error<>("encode: TPM2StartAuthSessionResponse::handle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nonceTPM.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2StartAuthSessionResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).handle, true)) {
            return ::futils::error::Error<>("decode: TPM2StartAuthSessionResponse::handle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nonceTPM.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct InprivateForLoadExternal {
        std::uint16_t sensitiveType = 0;
        Bytes16 authValue;
        Bytes16 seedValue;
        Bytes16 sensitiveData;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> InprivateForLoadExternal::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).sensitiveType), true)) {
            return ::futils::error::Error<>("encode: InprivateForLoadExternal::sensitiveType: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authValue.encode(w)) {
            return err;
        }
        if (auto err = (*this).seedValue.encode(w)) {
            return err;
        }
        if (auto err = (*this).sensitiveData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> InprivateForLoadExternal::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).sensitiveType, true)) {
            return ::futils::error::Error<>("decode: InprivateForLoadExternal::sensitiveType: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authValue.decode(r)) {
            return err;
        }
        if (auto err = (*this).seedValue.decode(r)) {
            return err;
        }
        if (auto err = (*this).sensitiveData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2LoadExternalResponseNoSession {
        std::uint32_t objectHandle = 0;
        Bytes16 name;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2LoadExternalResponseNoSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadExternalResponseNoSession::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2LoadExternalResponseNoSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadExternalResponseNoSession::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2LoadExternalResponseSession {
        std::uint32_t objectHandle = 0;
        std::uint32_t paramSize = 0;
        Bytes16 name;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2LoadExternalResponseSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadExternalResponseSession::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadExternalResponseSession::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2LoadExternalResponseSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadExternalResponseSession::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadExternalResponseSession::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ActivateCredentialResponse {
        std::uint32_t paramSize = 0;
        Bytes16 credentialInfo;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ActivateCredentialResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2ActivateCredentialResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).credentialInfo.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ActivateCredentialResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2ActivateCredentialResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).credentialInfo.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2MakeCredential {
        std::uint32_t handle = 0;
        Bytes16 credential;
        Bytes16 objectName;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2MakeCredential::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).handle), true)) {
            return ::futils::error::Error<>("encode: TPM2MakeCredential::handle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).credential.encode(w)) {
            return err;
        }
        if (auto err = (*this).objectName.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2MakeCredential::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).handle, true)) {
            return ::futils::error::Error<>("decode: TPM2MakeCredential::handle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).credential.decode(r)) {
            return err;
        }
        if (auto err = (*this).objectName.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2MakeCredentialResponse {
        Bytes16 credentialBlob;
        Bytes16 secret;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2MakeCredentialResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).credentialBlob.encode(w)) {
            return err;
        }
        if (auto err = (*this).secret.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2MakeCredentialResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).credentialBlob.decode(r)) {
            return err;
        }
        if (auto err = (*this).secret.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ObjectChangeAuthResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outPrivate;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ObjectChangeAuthResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2ObjectChangeAuthResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ObjectChangeAuthResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2ObjectChangeAuthResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2DuplicateResponse {
        std::uint32_t paramSize = 0;
        Bytes16 encryptionKeyOut;
        Bytes16 duplicate;
        Bytes16 outSymSeed;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2DuplicateResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2DuplicateResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).encryptionKeyOut.encode(w)) {
            return err;
        }
        if (auto err = (*this).duplicate.encode(w)) {
            return err;
        }
        if (auto err = (*this).outSymSeed.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2DuplicateResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2DuplicateResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).encryptionKeyOut.decode(r)) {
            return err;
        }
        if (auto err = (*this).duplicate.decode(r)) {
            return err;
        }
        if (auto err = (*this).outSymSeed.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2RewrapResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outDuplicate;
        Bytes16 outSymSeed;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2RewrapResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2RewrapResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outDuplicate.encode(w)) {
            return err;
        }
        if (auto err = (*this).outSymSeed.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2RewrapResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2RewrapResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outDuplicate.decode(r)) {
            return err;
        }
        if (auto err = (*this).outSymSeed.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ImportResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outPrivate;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ImportResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2ImportResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ImportResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2ImportResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2RSAEncryptResponseNoSession {
        Bytes16 outData;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2RSAEncryptResponseNoSession::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).outData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2RSAEncryptResponseNoSession::decode(::futils::binary::reader& r) {
        if (auto err = (*this).outData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2RSAEncryptResponseSession {
        std::uint32_t paramSize = 0;
        TPM2RSAEncryptResponseNoSession response;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2RSAEncryptResponseSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2RSAEncryptResponseSession::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2RSAEncryptResponseSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2RSAEncryptResponseSession::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2RSADecryptResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outData;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2RSADecryptResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2RSADecryptResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2RSADecryptResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2RSADecryptResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ECDHKeyGen {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ECDHKeyGen::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ECDHKeyGen::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ECDHKeyGen::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ECDHKeyGen::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ECDHKeyGenResponseNoSession {
        ECCPoint outZ;
        ECCPoint outPub;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2ECDHKeyGenResponseNoSession::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).outZ.encode(w)) {
            return err;
        }
        if (auto err = (*this).outPub.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ECDHKeyGenResponseNoSession::decode(::futils::binary::reader& r) {
        if (auto err = (*this).outZ.decode(r)) {
            return err;
        }
        if (auto err = (*this).outPub.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ECDHKeyGenResponseSession {
        std::uint32_t paramSize = 0;
        TPM2ECDHKeyGenResponseNoSession response;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ECDHKeyGenResponseSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2ECDHKeyGenResponseSession::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ECDHKeyGenResponseSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2ECDHKeyGenResponseSession::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ZGenResponse {
        std::uint32_t paramSize = 0;
        ECCPoint outPoint;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ZGenResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2ZGenResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPoint.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ZGenResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2ZGenResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPoint.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ZGen2PhaseResponse {
        std::uint32_t paramSize = 0;
        ECCPoint outZ1;
        ECCPoint outZ2;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ZGen2PhaseResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2ZGen2PhaseResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outZ1.encode(w)) {
            return err;
        }
        if (auto err = (*this).outZ2.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ZGen2PhaseResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2ZGen2PhaseResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outZ1.decode(r)) {
            return err;
        }
        if (auto err = (*this).outZ2.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EncryptDecryptResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outData;
        Bytes16 ivOut;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2EncryptDecryptResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecryptResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.encode(w)) {
            return err;
        }
        if (auto err = (*this).ivOut.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EncryptDecryptResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecryptResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.decode(r)) {
            return err;
        }
        if (auto err = (*this).ivOut.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EncryptDecrypt2Response {
        std::uint32_t paramSize = 0;
        Bytes16 outData;
        Bytes16 ivOut;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2EncryptDecrypt2Response::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt2Response::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.encode(w)) {
            return err;
        }
        if (auto err = (*this).ivOut.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EncryptDecrypt2Response::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt2Response::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outData.decode(r)) {
            return err;
        }
        if (auto err = (*this).ivOut.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Hash {
        Bytes16 data;
        TPMAlgorithmID hashAlg{};
        std::uint32_t hierarchy = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2Hash::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).data.encode(w)) {
            return err;
        }
        auto tmp_91_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_91_), true)) {
            return ::futils::error::Error<>("encode: TPM2Hash::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).hierarchy), true)) {
            return ::futils::error::Error<>("encode: TPM2Hash::hierarchy: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Hash::decode(::futils::binary::reader& r) {
        if (auto err = (*this).data.decode(r)) {
            return err;
        }
        std::uint16_t tmp_92_ = 0;
        if (!::futils::binary::read_num(r, tmp_92_, true)) {
            return ::futils::error::Error<>("decode: TPM2Hash::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_92_);
        if (!::futils::binary::read_num(r, (*this).hierarchy, true)) {
            return ::futils::error::Error<>("decode: TPM2Hash::hierarchy: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct Validation {
        std::uint16_t tag = 0;
        std::uint32_t hierarchy = 0;
        Bytes16 digest;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 6;
    };
    inline ::futils::error::Error<> Validation::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).tag), true)) {
            return ::futils::error::Error<>("encode: Validation::tag: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).hierarchy), true)) {
            return ::futils::error::Error<>("encode: Validation::hierarchy: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).digest.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Validation::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).tag, true)) {
            return ::futils::error::Error<>("decode: Validation::tag: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).hierarchy, true)) {
            return ::futils::error::Error<>("decode: Validation::hierarchy: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).digest.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2HashResponseNoSession {
        Bytes16 outHash;
        Validation validation;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2HashResponseNoSession::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).outHash.encode(w)) {
            return err;
        }
        if (auto err = (*this).validation.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HashResponseNoSession::decode(::futils::binary::reader& r) {
        if (auto err = (*this).outHash.decode(r)) {
            return err;
        }
        if (auto err = (*this).validation.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2HashResponseSession {
        std::uint32_t paramSize = 0;
        TPM2HashResponseNoSession response;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2HashResponseSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2HashResponseSession::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HashResponseSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2HashResponseSession::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2HMACResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outHMAC;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2HMACResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2HMACResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outHMAC.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HMACResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2HMACResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outHMAC.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EventSequenceCompleteResponse {
        std::uint32_t paramSize = 0;
        std::uint32_t resultCount = 0;
        std::vector<SignatureHMAC> results;
        bool set_results(auto&& v) {
            if (v.size() > ~std::uint32_t(0)) {
                return false;
            }
            (*this).resultCount = v.size();
            (*this).results = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2EventSequenceCompleteResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2EventSequenceCompleteResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).resultCount), true)) {
            return ::futils::error::Error<>("encode: TPM2EventSequenceCompleteResponse::resultCount: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_93_ = (*this).resultCount;
        if (tmp_93_ != (*this).results.size()) {
            return ::futils::error::Error<>("encode: TPM2EventSequenceCompleteResponse::results: dynamic length is not compatible with its length; tmp_93_!=(*this).results.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_94_ : (*this).results) {
            if (auto err = tmp_94_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EventSequenceCompleteResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2EventSequenceCompleteResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).resultCount, true)) {
            return ::futils::error::Error<>("decode: TPM2EventSequenceCompleteResponse::resultCount: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_95_ = (*this).resultCount;
        (*this).results.clear();
        for (size_t tmp_97_ = 0; tmp_97_ < tmp_95_; ++tmp_97_) {
            SignatureHMAC tmp_96_;
            if (auto err = tmp_96_.decode(r)) {
                return err;
            }
            (*this).results.push_back(std::move(tmp_96_));
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CommitResponse {
        std::uint32_t paramSize = 0;
        ECCPoint k;
        ECCPoint L;
        ECCPoint E;
        std::uint16_t counter = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2CommitResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2CommitResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).k.encode(w)) {
            return err;
        }
        if (auto err = (*this).L.encode(w)) {
            return err;
        }
        if (auto err = (*this).E.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).counter), true)) {
            return ::futils::error::Error<>("encode: TPM2CommitResponse::counter: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CommitResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2CommitResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).k.decode(r)) {
            return err;
        }
        if (auto err = (*this).L.decode(r)) {
            return err;
        }
        if (auto err = (*this).E.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).counter, true)) {
            return ::futils::error::Error<>("decode: TPM2CommitResponse::counter: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ECEphemeral {
        AuthCommand auth;
        std::uint32_t curveID = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
    };
    inline ::futils::error::Error<> TPM2ECEphemeral::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).curveID), true)) {
            return ::futils::error::Error<>("encode: TPM2ECEphemeral::curveID: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ECEphemeral::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).curveID, true)) {
            return ::futils::error::Error<>("decode: TPM2ECEphemeral::curveID: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EphemeralResponseNoSession {
        ECCPoint q;
        std::uint16_t counter = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2EphemeralResponseNoSession::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).q.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).counter), true)) {
            return ::futils::error::Error<>("encode: TPM2EphemeralResponseNoSession::counter: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EphemeralResponseNoSession::decode(::futils::binary::reader& r) {
        if (auto err = (*this).q.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).counter, true)) {
            return ::futils::error::Error<>("decode: TPM2EphemeralResponseNoSession::counter: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EphemeralResponseSession {
        std::uint32_t paramSize = 0;
        TPM2EphemeralResponseNoSession response;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2EphemeralResponseSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2EphemeralResponseSession::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EphemeralResponseSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2EphemeralResponseSession::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2VerifySignatureResponseNoSession {
        Validation validation;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2VerifySignatureResponseNoSession::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).validation.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2VerifySignatureResponseNoSession::decode(::futils::binary::reader& r) {
        if (auto err = (*this).validation.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2VerifySignatureResponseSession {
        std::uint32_t paramSize = 0;
        TPM2VerifySignatureResponseNoSession response;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2VerifySignatureResponseSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2VerifySignatureResponseSession::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2VerifySignatureResponseSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2VerifySignatureResponseSession::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).response.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct Signature {
        TPMAlgorithmID alg{};
        struct union_struct_100 {
            SignatureECDSA ecdaa;
        };
        struct union_struct_101 {
            SignatureECDSA ecdsa;
        };
        struct union_struct_102 {
            SignatureRSA rsassa;
        };
        struct union_struct_103 {
            SignatureRSA rsapss;
        };
        struct union_struct_104 {
            SignatureHMAC hmac;
        };
        std::variant<std::monostate, union_struct_100, union_struct_101, union_struct_102, union_struct_103, union_struct_104> union_variant_99;
        std::optional<SignatureECDSA> ecdaa() const {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                if (!std::holds_alternative<union_struct_100>(union_variant_99)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_99).ecdaa;
            }
            return std::nullopt;
        }
        bool ecdaa(const SignatureECDSA& v) {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                if (!std::holds_alternative<union_struct_100>(union_variant_99)) {
                    union_variant_99 = union_struct_100();
                }
                std::get<1>((*this).union_variant_99).ecdaa = v;
                return true;
            }
            return false;
        }
        std::optional<SignatureECDSA> ecdsa() const {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                if (!std::holds_alternative<union_struct_101>(union_variant_99)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_99).ecdsa;
            }
            return std::nullopt;
        }
        bool ecdsa(const SignatureECDSA& v) {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                if (!std::holds_alternative<union_struct_101>(union_variant_99)) {
                    union_variant_99 = union_struct_101();
                }
                std::get<2>((*this).union_variant_99).ecdsa = v;
                return true;
            }
            return false;
        }
        std::optional<SignatureHMAC> hmac() const {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_RSAPSS == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_HMAC == (*this).alg) {
                if (!std::holds_alternative<union_struct_104>(union_variant_99)) {
                    return std::nullopt;
                }
                return std::get<5>((*this).union_variant_99).hmac;
            }
            return std::nullopt;
        }
        bool hmac(const SignatureHMAC& v) {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_RSAPSS == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_HMAC == (*this).alg) {
                if (!std::holds_alternative<union_struct_104>(union_variant_99)) {
                    union_variant_99 = union_struct_104();
                }
                std::get<5>((*this).union_variant_99).hmac = v;
                return true;
            }
            return false;
        }
        std::optional<SignatureRSA> rsapss() const {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_RSAPSS == (*this).alg) {
                if (!std::holds_alternative<union_struct_103>(union_variant_99)) {
                    return std::nullopt;
                }
                return std::get<4>((*this).union_variant_99).rsapss;
            }
            return std::nullopt;
        }
        bool rsapss(const SignatureRSA& v) {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_RSAPSS == (*this).alg) {
                if (!std::holds_alternative<union_struct_103>(union_variant_99)) {
                    union_variant_99 = union_struct_103();
                }
                std::get<4>((*this).union_variant_99).rsapss = v;
                return true;
            }
            return false;
        }
        std::optional<SignatureRSA> rsassa() const {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                return std::nullopt;
            }
            if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
                if (!std::holds_alternative<union_struct_102>(union_variant_99)) {
                    return std::nullopt;
                }
                return std::get<3>((*this).union_variant_99).rsassa;
            }
            return std::nullopt;
        }
        bool rsassa(const SignatureRSA& v) {
            if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
                return false;
            }
            if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
                if (!std::holds_alternative<union_struct_102>(union_variant_99)) {
                    union_variant_99 = union_struct_102();
                }
                std::get<3>((*this).union_variant_99).rsassa = v;
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 2;
    };
    inline ::futils::error::Error<> Signature::encode(::futils::binary::writer& w) const {
        auto tmp_105_ = static_cast<std::uint16_t>((*this).alg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_105_), true)) {
            return ::futils::error::Error<>("encode: Signature::alg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
            if (!std::holds_alternative<union_struct_100>(union_variant_99)) {
                return ::futils::error::Error<>("encode: Signature: union_variant_99 variant alternative union_struct_100 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<1>((*this).union_variant_99).ecdaa.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
            if (!std::holds_alternative<union_struct_101>(union_variant_99)) {
                return ::futils::error::Error<>("encode: Signature: union_variant_99 variant alternative union_struct_101 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<2>((*this).union_variant_99).ecdsa.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
            if (!std::holds_alternative<union_struct_102>(union_variant_99)) {
                return ::futils::error::Error<>("encode: Signature: union_variant_99 variant alternative union_struct_102 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<3>((*this).union_variant_99).rsassa.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_RSAPSS == (*this).alg) {
            if (!std::holds_alternative<union_struct_103>(union_variant_99)) {
                return ::futils::error::Error<>("encode: Signature: union_variant_99 variant alternative union_struct_103 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<4>((*this).union_variant_99).rsapss.encode(w)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_HMAC == (*this).alg) {
            if (!std::holds_alternative<union_struct_104>(union_variant_99)) {
                return ::futils::error::Error<>("encode: Signature: union_variant_99 variant alternative union_struct_104 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<5>((*this).union_variant_99).hmac.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> Signature::decode(::futils::binary::reader& r) {
        std::uint16_t tmp_106_ = 0;
        if (!::futils::binary::read_num(r, tmp_106_, true)) {
            return ::futils::error::Error<>("decode: Signature::alg: read int failed", ::futils::error::Category::lib);
        }
        (*this).alg = static_cast<TPMAlgorithmID>(tmp_106_);
        if (TPMAlgorithmID::TPM_ALG_ECDAA == (*this).alg) {
            if (!std::holds_alternative<union_struct_100>(union_variant_99)) {
                union_variant_99 = union_struct_100();
            }
            if (auto err = std::get<1>((*this).union_variant_99).ecdaa.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_ECDSA == (*this).alg) {
            if (!std::holds_alternative<union_struct_101>(union_variant_99)) {
                union_variant_99 = union_struct_101();
            }
            if (auto err = std::get<2>((*this).union_variant_99).ecdsa.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_RSASSA == (*this).alg) {
            if (!std::holds_alternative<union_struct_102>(union_variant_99)) {
                union_variant_99 = union_struct_102();
            }
            if (auto err = std::get<3>((*this).union_variant_99).rsassa.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_RSAPSS == (*this).alg) {
            if (!std::holds_alternative<union_struct_103>(union_variant_99)) {
                union_variant_99 = union_struct_103();
            }
            if (auto err = std::get<4>((*this).union_variant_99).rsapss.decode(r)) {
                return err;
            }
        }
        else if (TPMAlgorithmID::TPM_ALG_HMAC == (*this).alg) {
            if (!std::holds_alternative<union_struct_104>(union_variant_99)) {
                union_variant_99 = union_struct_104();
            }
            if (auto err = std::get<5>((*this).union_variant_99).hmac.decode(r)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    struct TPM2SignResponse {
        std::uint32_t paramSize = 0;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2SignResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2SignResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2SignResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2SignResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestHeader {
        std::uint32_t magic = 0;
        TPMAttestType type{};
        Bytes16 qualified_signer;
        Bytes16 extra_data;
        ClockInfo clock_info;
        std::uint64_t firmware_version = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 6;
    };
    inline ::futils::error::Error<> TPMAttestHeader::encode(::futils::binary::writer& w) const {
        if (TPM_GENERATED_VALUE != (*this).magic) {
            return ::futils::error::Error<>("encode: TPMAttestHeader::magic: field value is not equal to TPM_GENERATED_VALUE", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).magic), true)) {
            return ::futils::error::Error<>("encode: TPMAttestHeader::magic: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_107_ = static_cast<std::uint16_t>((*this).type);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_107_), true)) {
            return ::futils::error::Error<>("encode: TPMAttestHeader::type: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).qualified_signer.encode(w)) {
            return err;
        }
        if (auto err = (*this).extra_data.encode(w)) {
            return err;
        }
        if (auto err = (*this).clock_info.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).firmware_version), true)) {
            return ::futils::error::Error<>("encode: TPMAttestHeader::firmware_version: write std::uint64_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestHeader::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).magic, true)) {
            return ::futils::error::Error<>("decode: TPMAttestHeader::magic: read int failed", ::futils::error::Category::lib);
        }
        if ((*this).magic != TPM_GENERATED_VALUE) {
            return ::futils::error::Error<>("decode: TPMAttestHeader::magic: field value is not equal to TPM_GENERATED_VALUE", ::futils::error::Category::lib);
        }
        std::uint16_t tmp_108_ = 0;
        if (!::futils::binary::read_num(r, tmp_108_, true)) {
            return ::futils::error::Error<>("decode: TPMAttestHeader::type: read int failed", ::futils::error::Category::lib);
        }
        (*this).type = static_cast<TPMAttestType>(tmp_108_);
        if (auto err = (*this).qualified_signer.decode(r)) {
            return err;
        }
        if (auto err = (*this).extra_data.decode(r)) {
            return err;
        }
        if (auto err = (*this).clock_info.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).firmware_version, true)) {
            return ::futils::error::Error<>("decode: TPMAttestHeader::firmware_version: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttestQuote {
        PCR pcr;
        Bytes16 pcrDigest;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMAttestQuote::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).pcr.encode(w)) {
            return err;
        }
        if (auto err = (*this).pcrDigest.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttestQuote::decode(::futils::binary::reader& r) {
        if (auto err = (*this).pcr.decode(r)) {
            return err;
        }
        if (auto err = (*this).pcrDigest.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct ResponseProcess {
        TPMPacketHeader header;
        std::uint32_t handle = 0;
        std::uint32_t param_size = 0;
        std::uint16_t dec_param_size = 0;
        ::futils::view::rvec param;
        std::vector<AuthResponse> auth;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 20;
    };
    inline ::futils::error::Error<> ResponseProcess::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).header.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).handle), true)) {
            return ::futils::error::Error<>("encode: ResponseProcess::handle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).param_size), true)) {
            return ::futils::error::Error<>("encode: ResponseProcess::param_size: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).dec_param_size), true)) {
            return ::futils::error::Error<>("encode: ResponseProcess::dec_param_size: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_109_ = (*this).param_size - 2;
        if (tmp_109_ != (*this).param.size()) {
            return ::futils::error::Error<>("encode: ResponseProcess::param: dynamic length is not compatible with its length; tmp_109_!=(*this).param.size()", ::futils::error::Category::lib);
        }
        if (!w.write((*this).param)) {
            return ::futils::error::Error<>("encode: ResponseProcess::param: write array failed", ::futils::error::Category::lib);
        }
        for (auto& tmp_110_ : (*this).auth) {
            if (auto err = tmp_110_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> ResponseProcess::decode(::futils::binary::reader& r) {
        if (auto err = (*this).header.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).handle, true)) {
            return ::futils::error::Error<>("decode: ResponseProcess::handle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).param_size, true)) {
            return ::futils::error::Error<>("decode: ResponseProcess::param_size: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).dec_param_size, true)) {
            return ::futils::error::Error<>("decode: ResponseProcess::dec_param_size: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_111_ = (*this).param_size - 2;
        if (!r.read((*this).param, tmp_111_)) {
            return ::futils::error::Error<>("decode: ResponseProcess::param: read byte array failed", ::futils::error::Category::lib);
        }
        (*this).auth.clear();
        for (;;) {
            if (!r.load_stream(1)) {
                break;  // reached EOF
            }
            AuthResponse tmp_112_;
            if (auto err = tmp_112_.decode(r)) {
                return err;
            }
            (*this).auth.push_back(std::move(tmp_112_));
        }
        return ::futils::error::Error<>();
    }
    struct TPM2PCRReadResponse {
        std::uint32_t updateCounter = 0;
        PCR pcr;
        std::uint32_t pcrValueCount = 0;
        std::vector<Bytes16> pcrValues;
        bool set_pcrValues(auto&& v) {
            if (v.size() > ~std::uint32_t(0)) {
                return false;
            }
            (*this).pcrValueCount = v.size();
            (*this).pcrValues = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2PCRReadResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).updateCounter), true)) {
            return ::futils::error::Error<>("encode: TPM2PCRReadResponse::updateCounter: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).pcr.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).pcrValueCount), true)) {
            return ::futils::error::Error<>("encode: TPM2PCRReadResponse::pcrValueCount: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_113_ = (*this).pcrValueCount;
        if (tmp_113_ != (*this).pcrValues.size()) {
            return ::futils::error::Error<>("encode: TPM2PCRReadResponse::pcrValues: dynamic length is not compatible with its length; tmp_113_!=(*this).pcrValues.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_114_ : (*this).pcrValues) {
            if (auto err = tmp_114_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2PCRReadResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).updateCounter, true)) {
            return ::futils::error::Error<>("decode: TPM2PCRReadResponse::updateCounter: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).pcr.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).pcrValueCount, true)) {
            return ::futils::error::Error<>("decode: TPM2PCRReadResponse::pcrValueCount: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_115_ = (*this).pcrValueCount;
        (*this).pcrValues.clear();
        for (size_t tmp_117_ = 0; tmp_117_ < tmp_115_; ++tmp_117_) {
            Bytes16 tmp_116_;
            if (auto err = tmp_116_.decode(r)) {
                return err;
            }
            (*this).pcrValues.push_back(std::move(tmp_116_));
        }
        return ::futils::error::Error<>();
    }
    struct TPM2PCRExtend {
        std::uint32_t pcrHandle = 0;
        AuthCommand auth;
        std::uint32_t digestCount = 0;
        std::vector<SignatureHMAC> digests;
        bool set_digests(auto&& v) {
            if (v.size() > ~std::uint32_t(0)) {
                return false;
            }
            (*this).digestCount = v.size();
            (*this).digests = std::forward<decltype(v)>(v);
            return true;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2PCRExtend::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).pcrHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2PCRExtend::pcrHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).digestCount), true)) {
            return ::futils::error::Error<>("encode: TPM2PCRExtend::digestCount: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        auto tmp_118_ = (*this).digestCount;
        if (tmp_118_ != (*this).digests.size()) {
            return ::futils::error::Error<>("encode: TPM2PCRExtend::digests: dynamic length is not compatible with its length; tmp_118_!=(*this).digests.size()", ::futils::error::Category::lib);
        }
        for (auto& tmp_119_ : (*this).digests) {
            if (auto err = tmp_119_.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2PCRExtend::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).pcrHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2PCRExtend::pcrHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).digestCount, true)) {
            return ::futils::error::Error<>("decode: TPM2PCRExtend::digestCount: read int failed", ::futils::error::Category::lib);
        }
        auto tmp_120_ = (*this).digestCount;
        (*this).digests.clear();
        for (size_t tmp_122_ = 0; tmp_122_ < tmp_120_; ++tmp_122_) {
            SignatureHMAC tmp_121_;
            if (auto err = tmp_121_.decode(r)) {
                return err;
            }
            (*this).digests.push_back(std::move(tmp_121_));
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CreateLoadedResponse {
        std::uint32_t objectHandle = 0;
        std::uint32_t paramSize = 0;
        Bytes16 outPrivate;
        TPMPublicKey outPublic;
        Bytes16 name;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2CreateLoadedResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateLoadedResponse::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateLoadedResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.encode(w)) {
            return err;
        }
        if (auto err = (*this).outPublic.encode(w)) {
            return err;
        }
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CreateLoadedResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateLoadedResponse::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateLoadedResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outPrivate.decode(r)) {
            return err;
        }
        if (auto err = (*this).outPublic.decode(r)) {
            return err;
        }
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2StartAuthSession {
        std::uint32_t tpmKey = 0;
        std::uint32_t bind = 0;
        Bytes16 nonceCaller;
        Bytes16 encryptedSalt;
        std::uint8_t sessionType = 0;
        TPMSymetric symmetric;
        TPMAlgorithmID authHash{};
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2StartAuthSession::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).tpmKey), true)) {
            return ::futils::error::Error<>("encode: TPM2StartAuthSession::tpmKey: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).bind), true)) {
            return ::futils::error::Error<>("encode: TPM2StartAuthSession::bind: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nonceCaller.encode(w)) {
            return err;
        }
        if (auto err = (*this).encryptedSalt.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).sessionType), true)) {
            return ::futils::error::Error<>("encode: TPM2StartAuthSession::sessionType: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).symmetric.encode(w)) {
            return err;
        }
        auto tmp_123_ = static_cast<std::uint16_t>((*this).authHash);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_123_), true)) {
            return ::futils::error::Error<>("encode: TPM2StartAuthSession::authHash: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2StartAuthSession::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).tpmKey, true)) {
            return ::futils::error::Error<>("decode: TPM2StartAuthSession::tpmKey: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).bind, true)) {
            return ::futils::error::Error<>("decode: TPM2StartAuthSession::bind: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).nonceCaller.decode(r)) {
            return err;
        }
        if (auto err = (*this).encryptedSalt.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).sessionType, true)) {
            return ::futils::error::Error<>("decode: TPM2StartAuthSession::sessionType: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).symmetric.decode(r)) {
            return err;
        }
        std::uint16_t tmp_124_ = 0;
        if (!::futils::binary::read_num(r, tmp_124_, true)) {
            return ::futils::error::Error<>("decode: TPM2StartAuthSession::authHash: read int failed", ::futils::error::Category::lib);
        }
        (*this).authHash = static_cast<TPMAlgorithmID>(tmp_124_);
        return ::futils::error::Error<>();
    }
    struct TPM2ReadPublicResponse {
        TPMPublicKey outPublic;
        Bytes16 name;
        Bytes16 qualifiedName;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPM2ReadPublicResponse::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).outPublic.encode(w)) {
            return err;
        }
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        if (auto err = (*this).qualifiedName.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ReadPublicResponse::decode(::futils::binary::reader& r) {
        if (auto err = (*this).outPublic.decode(r)) {
            return err;
        }
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        if (auto err = (*this).qualifiedName.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ActivateCredential {
        std::uint32_t activateHandle = 0;
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 credBlob;
        Bytes16 secret;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2ActivateCredential::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).activateHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ActivateCredential::activateHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ActivateCredential::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).credBlob.encode(w)) {
            return err;
        }
        if (auto err = (*this).secret.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ActivateCredential::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).activateHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ActivateCredential::activateHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ActivateCredential::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).credBlob.decode(r)) {
            return err;
        }
        if (auto err = (*this).secret.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ObjectChangeAuth {
        std::uint32_t objectHandle = 0;
        std::uint32_t parentHandle = 0;
        AuthCommand auth;
        Bytes16 newAuth;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2ObjectChangeAuth::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ObjectChangeAuth::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).parentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ObjectChangeAuth::parentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).newAuth.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ObjectChangeAuth::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ObjectChangeAuth::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).parentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ObjectChangeAuth::parentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).newAuth.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Duplicate {
        std::uint32_t objectHandle = 0;
        std::uint32_t newParentHandle = 0;
        AuthCommand auth;
        Bytes16 encryptionKey;
        TPMAlgorithmID symmetricAlg{};
        std::uint16_t symmetricKeyBits = 0;
        std::uint16_t symmetricMode = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2Duplicate::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Duplicate::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).newParentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Duplicate::newParentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).encryptionKey.encode(w)) {
            return err;
        }
        auto tmp_125_ = static_cast<std::uint16_t>((*this).symmetricAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_125_), true)) {
            return ::futils::error::Error<>("encode: TPM2Duplicate::symmetricAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).symmetricKeyBits), true)) {
            return ::futils::error::Error<>("encode: TPM2Duplicate::symmetricKeyBits: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).symmetricMode), true)) {
            return ::futils::error::Error<>("encode: TPM2Duplicate::symmetricMode: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Duplicate::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Duplicate::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).newParentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Duplicate::newParentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).encryptionKey.decode(r)) {
            return err;
        }
        std::uint16_t tmp_126_ = 0;
        if (!::futils::binary::read_num(r, tmp_126_, true)) {
            return ::futils::error::Error<>("decode: TPM2Duplicate::symmetricAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).symmetricAlg = static_cast<TPMAlgorithmID>(tmp_126_);
        if (!::futils::binary::read_num(r, (*this).symmetricKeyBits, true)) {
            return ::futils::error::Error<>("decode: TPM2Duplicate::symmetricKeyBits: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).symmetricMode, true)) {
            return ::futils::error::Error<>("decode: TPM2Duplicate::symmetricMode: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Rewrap {
        std::uint32_t oldParent = 0;
        std::uint32_t newParent = 0;
        AuthCommand auth;
        Bytes16 inDuplicate;
        Bytes16 name;
        Bytes16 inSymSeed;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2Rewrap::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).oldParent), true)) {
            return ::futils::error::Error<>("encode: TPM2Rewrap::oldParent: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).newParent), true)) {
            return ::futils::error::Error<>("encode: TPM2Rewrap::newParent: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).inDuplicate.encode(w)) {
            return err;
        }
        if (auto err = (*this).name.encode(w)) {
            return err;
        }
        if (auto err = (*this).inSymSeed.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Rewrap::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).oldParent, true)) {
            return ::futils::error::Error<>("decode: TPM2Rewrap::oldParent: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).newParent, true)) {
            return ::futils::error::Error<>("decode: TPM2Rewrap::newParent: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).inDuplicate.decode(r)) {
            return err;
        }
        if (auto err = (*this).name.decode(r)) {
            return err;
        }
        if (auto err = (*this).inSymSeed.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2RSAEncrypt {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 message;
        TPMAlgorithmID inScheme{};
        struct union_struct_129 {
            TPMAlgorithmID hashAlg{};
        };
        std::variant<std::monostate, union_struct_129> union_variant_128;
        std::optional<TPMAlgorithmID> hashAlg() const {
            if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES) == true) {
                if (!std::holds_alternative<union_struct_129>(union_variant_128)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_128).hashAlg;
            }
            return std::nullopt;
        }
        bool hashAlg(const TPMAlgorithmID& v) {
            if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES) == true) {
                if (!std::holds_alternative<union_struct_129>(union_variant_128)) {
                    union_variant_128 = union_struct_129();
                }
                std::get<1>((*this).union_variant_128).hashAlg = v;
                return true;
            }
            return false;
        }
        Bytes16 label;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2RSAEncrypt::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2RSAEncrypt::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).message.encode(w)) {
            return err;
        }
        auto tmp_130_ = static_cast<std::uint16_t>((*this).inScheme);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_130_), true)) {
            return ::futils::error::Error<>("encode: TPM2RSAEncrypt::inScheme: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES)) {
            if (!std::holds_alternative<union_struct_129>(union_variant_128)) {
                return ::futils::error::Error<>("encode: TPM2RSAEncrypt: union_variant_128 variant alternative union_struct_129 is not set", ::futils::error::Category::lib);
            }
            auto tmp_131_ = static_cast<std::uint16_t>(std::get<1>((*this).union_variant_128).hashAlg);
            if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_131_), true)) {
                return ::futils::error::Error<>("encode: TPM2RSAEncrypt::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
            }
        }
        if (auto err = (*this).label.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2RSAEncrypt::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2RSAEncrypt::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).message.decode(r)) {
            return err;
        }
        std::uint16_t tmp_132_ = 0;
        if (!::futils::binary::read_num(r, tmp_132_, true)) {
            return ::futils::error::Error<>("decode: TPM2RSAEncrypt::inScheme: read int failed", ::futils::error::Category::lib);
        }
        (*this).inScheme = static_cast<TPMAlgorithmID>(tmp_132_);
        if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES)) {
            if (!std::holds_alternative<union_struct_129>(union_variant_128)) {
                union_variant_128 = union_struct_129();
            }
            std::uint16_t tmp_133_ = 0;
            if (!::futils::binary::read_num(r, tmp_133_, true)) {
                return ::futils::error::Error<>("decode: TPM2RSAEncrypt::hashAlg: read int failed", ::futils::error::Category::lib);
            }
            std::get<1>((*this).union_variant_128).hashAlg = static_cast<TPMAlgorithmID>(tmp_133_);
        }
        if (auto err = (*this).label.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2RSADecrypt {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 cipher;
        TPMAlgorithmID inScheme{};
        struct union_struct_136 {
            TPMAlgorithmID hashAlg{};
        };
        std::variant<std::monostate, union_struct_136> union_variant_135;
        std::optional<TPMAlgorithmID> hashAlg() const {
            if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES) == true) {
                if (!std::holds_alternative<union_struct_136>(union_variant_135)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_135).hashAlg;
            }
            return std::nullopt;
        }
        bool hashAlg(const TPMAlgorithmID& v) {
            if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES) == true) {
                if (!std::holds_alternative<union_struct_136>(union_variant_135)) {
                    union_variant_135 = union_struct_136();
                }
                std::get<1>((*this).union_variant_135).hashAlg = v;
                return true;
            }
            return false;
        }
        Bytes16 label;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2RSADecrypt::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2RSADecrypt::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).cipher.encode(w)) {
            return err;
        }
        auto tmp_137_ = static_cast<std::uint16_t>((*this).inScheme);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_137_), true)) {
            return ::futils::error::Error<>("encode: TPM2RSADecrypt::inScheme: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES)) {
            if (!std::holds_alternative<union_struct_136>(union_variant_135)) {
                return ::futils::error::Error<>("encode: TPM2RSADecrypt: union_variant_135 variant alternative union_struct_136 is not set", ::futils::error::Category::lib);
            }
            auto tmp_138_ = static_cast<std::uint16_t>(std::get<1>((*this).union_variant_135).hashAlg);
            if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_138_), true)) {
                return ::futils::error::Error<>("encode: TPM2RSADecrypt::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
            }
        }
        if (auto err = (*this).label.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2RSADecrypt::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2RSADecrypt::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).cipher.decode(r)) {
            return err;
        }
        std::uint16_t tmp_139_ = 0;
        if (!::futils::binary::read_num(r, tmp_139_, true)) {
            return ::futils::error::Error<>("decode: TPM2RSADecrypt::inScheme: read int failed", ::futils::error::Category::lib);
        }
        (*this).inScheme = static_cast<TPMAlgorithmID>(tmp_139_);
        if (((*this).inScheme != TPMAlgorithmID::TPM_ALG_NULL) && ((*this).inScheme != TPMAlgorithmID::TPM_ALG_RSAES)) {
            if (!std::holds_alternative<union_struct_136>(union_variant_135)) {
                union_variant_135 = union_struct_136();
            }
            std::uint16_t tmp_140_ = 0;
            if (!::futils::binary::read_num(r, tmp_140_, true)) {
                return ::futils::error::Error<>("decode: TPM2RSADecrypt::hashAlg: read int failed", ::futils::error::Category::lib);
            }
            std::get<1>((*this).union_variant_135).hashAlg = static_cast<TPMAlgorithmID>(tmp_140_);
        }
        if (auto err = (*this).label.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ZGen {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        ECCPoint inPoint;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ZGen::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2ZGen::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).inPoint.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ZGen::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2ZGen::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).inPoint.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ZGen2Phase {
        std::uint32_t keyA = 0;
        AuthCommand auth;
        ECCPoint inQsB;
        ECCPoint inQeB;
        TPMAlgorithmID inScheme{};
        std::uint16_t counter = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ZGen2Phase::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyA), true)) {
            return ::futils::error::Error<>("encode: TPM2ZGen2Phase::keyA: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).inQsB.encode(w)) {
            return err;
        }
        if (auto err = (*this).inQeB.encode(w)) {
            return err;
        }
        auto tmp_141_ = static_cast<std::uint16_t>((*this).inScheme);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_141_), true)) {
            return ::futils::error::Error<>("encode: TPM2ZGen2Phase::inScheme: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).counter), true)) {
            return ::futils::error::Error<>("encode: TPM2ZGen2Phase::counter: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ZGen2Phase::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyA, true)) {
            return ::futils::error::Error<>("decode: TPM2ZGen2Phase::keyA: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).inQsB.decode(r)) {
            return err;
        }
        if (auto err = (*this).inQeB.decode(r)) {
            return err;
        }
        std::uint16_t tmp_142_ = 0;
        if (!::futils::binary::read_num(r, tmp_142_, true)) {
            return ::futils::error::Error<>("decode: TPM2ZGen2Phase::inScheme: read int failed", ::futils::error::Category::lib);
        }
        (*this).inScheme = static_cast<TPMAlgorithmID>(tmp_142_);
        if (!::futils::binary::read_num(r, (*this).counter, true)) {
            return ::futils::error::Error<>("decode: TPM2ZGen2Phase::counter: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EncryptDecrypt {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        std::uint8_t decrypt = 0;
        std::uint16_t mode = 0;
        Bytes16 ivIn;
        Bytes16 inData;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2EncryptDecrypt::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).decrypt), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt::decrypt: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).mode), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt::mode: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).ivIn.encode(w)) {
            return err;
        }
        if (auto err = (*this).inData.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EncryptDecrypt::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).decrypt, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt::decrypt: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).mode, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt::mode: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).ivIn.decode(r)) {
            return err;
        }
        if (auto err = (*this).inData.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EncryptDecrypt2 {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 inData;
        std::uint8_t decrypt = 0;
        std::uint16_t mode = 0;
        Bytes16 ivIn;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2EncryptDecrypt2::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt2::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).inData.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint8_t>((*this).decrypt), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt2::decrypt: write std::uint8_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).mode), true)) {
            return ::futils::error::Error<>("encode: TPM2EncryptDecrypt2::mode: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).ivIn.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EncryptDecrypt2::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt2::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).inData.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).decrypt, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt2::decrypt: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).mode, true)) {
            return ::futils::error::Error<>("decode: TPM2EncryptDecrypt2::mode: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).ivIn.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2HMAC {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 data;
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2HMAC::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2HMAC::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).data.encode(w)) {
            return err;
        }
        auto tmp_143_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_143_), true)) {
            return ::futils::error::Error<>("encode: TPM2HMAC::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HMAC::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2HMAC::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).data.decode(r)) {
            return err;
        }
        std::uint16_t tmp_144_ = 0;
        if (!::futils::binary::read_num(r, tmp_144_, true)) {
            return ::futils::error::Error<>("decode: TPM2HMAC::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_144_);
        return ::futils::error::Error<>();
    }
    struct TPM2HMACStart {
        std::uint32_t keyHandle = 0;
        AuthCommand authCommand;
        Bytes16 auth;
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2HMACStart::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2HMACStart::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authCommand.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).auth.encode(w)) {
            return err;
        }
        auto tmp_145_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_145_), true)) {
            return ::futils::error::Error<>("encode: TPM2HMACStart::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HMACStart::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2HMACStart::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).authCommand.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).auth.decode(r)) {
            return err;
        }
        std::uint16_t tmp_146_ = 0;
        if (!::futils::binary::read_num(r, tmp_146_, true)) {
            return ::futils::error::Error<>("decode: TPM2HMACStart::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_146_);
        return ::futils::error::Error<>();
    }
    struct TPM2HashSequenceStart {
        AuthCommand authCommand;
        Bytes16 auth;
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
    };
    inline ::futils::error::Error<> TPM2HashSequenceStart::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (auto err = (*this).authCommand.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).auth.encode(w)) {
            return err;
        }
        auto tmp_147_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_147_), true)) {
            return ::futils::error::Error<>("encode: TPM2HashSequenceStart::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2HashSequenceStart::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (auto err = (*this).authCommand.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).auth.decode(r)) {
            return err;
        }
        std::uint16_t tmp_148_ = 0;
        if (!::futils::binary::read_num(r, tmp_148_, true)) {
            return ::futils::error::Error<>("decode: TPM2HashSequenceStart::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_148_);
        return ::futils::error::Error<>();
    }
    struct TPM2SequenceUpdate {
        std::uint32_t sequenceHandle = 0;
        AuthCommand auth;
        Bytes16 buffer;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2SequenceUpdate::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).sequenceHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2SequenceUpdate::sequenceHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).buffer.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2SequenceUpdate::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).sequenceHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2SequenceUpdate::sequenceHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).buffer.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2SequenceComplete {
        std::uint32_t sequenceHandle = 0;
        AuthCommand auth;
        Bytes16 buffer;
        std::uint32_t hierarchy = 0;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2SequenceComplete::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).sequenceHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2SequenceComplete::sequenceHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).buffer.encode(w)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).hierarchy), true)) {
            return ::futils::error::Error<>("encode: TPM2SequenceComplete::hierarchy: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2SequenceComplete::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).sequenceHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2SequenceComplete::sequenceHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).buffer.decode(r)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).hierarchy, true)) {
            return ::futils::error::Error<>("decode: TPM2SequenceComplete::hierarchy: read int failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    struct TPM2SequenceCompleteResponse {
        std::uint32_t paramSize = 0;
        Bytes16 outHash;
        Validation validation;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2SequenceCompleteResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2SequenceCompleteResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outHash.encode(w)) {
            return err;
        }
        if (auto err = (*this).validation.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2SequenceCompleteResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2SequenceCompleteResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).outHash.decode(r)) {
            return err;
        }
        if (auto err = (*this).validation.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2EventSequenceComplete {
        std::uint32_t pcrHandle = 0;
        std::uint32_t sequenceHandle = 0;
        AuthCommand auth;
        Bytes16 buffer;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2EventSequenceComplete::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).pcrHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2EventSequenceComplete::pcrHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).sequenceHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2EventSequenceComplete::sequenceHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).buffer.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2EventSequenceComplete::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).pcrHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2EventSequenceComplete::pcrHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).sequenceHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2EventSequenceComplete::sequenceHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).buffer.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Certify {
        std::uint32_t objectHandle = 0;
        std::uint32_t signHandle = 0;
        AuthCommand auth;
        Bytes16 qualifyingData;
        TPMAlgorithmID schemeAlg{};
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2Certify::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Certify::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Certify::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.encode(w)) {
            return err;
        }
        auto tmp_149_ = static_cast<std::uint16_t>((*this).schemeAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_149_), true)) {
            return ::futils::error::Error<>("encode: TPM2Certify::schemeAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_150_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_150_), true)) {
            return ::futils::error::Error<>("encode: TPM2Certify::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Certify::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Certify::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Certify::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.decode(r)) {
            return err;
        }
        std::uint16_t tmp_151_ = 0;
        if (!::futils::binary::read_num(r, tmp_151_, true)) {
            return ::futils::error::Error<>("decode: TPM2Certify::schemeAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).schemeAlg = static_cast<TPMAlgorithmID>(tmp_151_);
        std::uint16_t tmp_152_ = 0;
        if (!::futils::binary::read_num(r, tmp_152_, true)) {
            return ::futils::error::Error<>("decode: TPM2Certify::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_152_);
        return ::futils::error::Error<>();
    }
    struct TPM2CertifyResponse {
        std::uint32_t paramSize = 0;
        Bytes16 certifyInfo;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2CertifyResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2CertifyResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).certifyInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CertifyResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2CertifyResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).certifyInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CertifyCreateResponse {
        std::uint32_t paramSize = 0;
        Bytes16 certifyInfo;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2CertifyCreateResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2CertifyCreateResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).certifyInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CertifyCreateResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2CertifyCreateResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).certifyInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2QuoteResponse {
        std::uint32_t paramSize = 0;
        Bytes16 quoted;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2QuoteResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2QuoteResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).quoted.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2QuoteResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2QuoteResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).quoted.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2GetSessionAuditDigest {
        std::uint32_t privacyAdminHandle = 0;
        std::uint32_t signHandle = 0;
        AuthCommand auth;
        std::uint32_t sessionHandle = 0;
        Bytes16 qualifyingData;
        TPMAlgorithmID schemeAlg{};
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2GetSessionAuditDigest::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).privacyAdminHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetSessionAuditDigest::privacyAdminHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetSessionAuditDigest::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).sessionHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetSessionAuditDigest::sessionHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).qualifyingData.encode(w)) {
            return err;
        }
        auto tmp_153_ = static_cast<std::uint16_t>((*this).schemeAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_153_), true)) {
            return ::futils::error::Error<>("encode: TPM2GetSessionAuditDigest::schemeAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_154_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_154_), true)) {
            return ::futils::error::Error<>("encode: TPM2GetSessionAuditDigest::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2GetSessionAuditDigest::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).privacyAdminHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetSessionAuditDigest::privacyAdminHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetSessionAuditDigest::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).sessionHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetSessionAuditDigest::sessionHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).qualifyingData.decode(r)) {
            return err;
        }
        std::uint16_t tmp_155_ = 0;
        if (!::futils::binary::read_num(r, tmp_155_, true)) {
            return ::futils::error::Error<>("decode: TPM2GetSessionAuditDigest::schemeAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).schemeAlg = static_cast<TPMAlgorithmID>(tmp_155_);
        std::uint16_t tmp_156_ = 0;
        if (!::futils::binary::read_num(r, tmp_156_, true)) {
            return ::futils::error::Error<>("decode: TPM2GetSessionAuditDigest::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_156_);
        return ::futils::error::Error<>();
    }
    struct TPM2GetSessionAuditDigestResponse {
        std::uint32_t paramSize = 0;
        Bytes16 auditInfo;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2GetSessionAuditDigestResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2GetSessionAuditDigestResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auditInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2GetSessionAuditDigestResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2GetSessionAuditDigestResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auditInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2GetCommandAuditDigest {
        std::uint32_t privacyAdminHandle = 0;
        std::uint32_t signHandle = 0;
        AuthCommand auth;
        Bytes16 qualifyingData;
        TPMAlgorithmID schemeAlg{};
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2GetCommandAuditDigest::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).privacyAdminHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetCommandAuditDigest::privacyAdminHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetCommandAuditDigest::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.encode(w)) {
            return err;
        }
        auto tmp_157_ = static_cast<std::uint16_t>((*this).schemeAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_157_), true)) {
            return ::futils::error::Error<>("encode: TPM2GetCommandAuditDigest::schemeAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_158_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_158_), true)) {
            return ::futils::error::Error<>("encode: TPM2GetCommandAuditDigest::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2GetCommandAuditDigest::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).privacyAdminHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetCommandAuditDigest::privacyAdminHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetCommandAuditDigest::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.decode(r)) {
            return err;
        }
        std::uint16_t tmp_159_ = 0;
        if (!::futils::binary::read_num(r, tmp_159_, true)) {
            return ::futils::error::Error<>("decode: TPM2GetCommandAuditDigest::schemeAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).schemeAlg = static_cast<TPMAlgorithmID>(tmp_159_);
        std::uint16_t tmp_160_ = 0;
        if (!::futils::binary::read_num(r, tmp_160_, true)) {
            return ::futils::error::Error<>("decode: TPM2GetCommandAuditDigest::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_160_);
        return ::futils::error::Error<>();
    }
    struct TPM2GetCommandAuditDigestResponse {
        std::uint32_t paramSize = 0;
        Bytes16 attestationData;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2GetCommandAuditDigestResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2GetCommandAuditDigestResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).attestationData.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2GetCommandAuditDigestResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2GetCommandAuditDigestResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).attestationData.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2GetTime {
        std::uint32_t privacyAdminHandle = 0;
        std::uint32_t signHandle = 0;
        AuthCommand auth;
        Bytes16 qualifyingData;
        TPMAlgorithmID schemeAlg{};
        TPMAlgorithmID hashAlg{};
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2GetTime::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).privacyAdminHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetTime::privacyAdminHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2GetTime::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.encode(w)) {
            return err;
        }
        auto tmp_161_ = static_cast<std::uint16_t>((*this).schemeAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_161_), true)) {
            return ::futils::error::Error<>("encode: TPM2GetTime::schemeAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_162_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_162_), true)) {
            return ::futils::error::Error<>("encode: TPM2GetTime::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2GetTime::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).privacyAdminHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetTime::privacyAdminHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2GetTime::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.decode(r)) {
            return err;
        }
        std::uint16_t tmp_163_ = 0;
        if (!::futils::binary::read_num(r, tmp_163_, true)) {
            return ::futils::error::Error<>("decode: TPM2GetTime::schemeAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).schemeAlg = static_cast<TPMAlgorithmID>(tmp_163_);
        std::uint16_t tmp_164_ = 0;
        if (!::futils::binary::read_num(r, tmp_164_, true)) {
            return ::futils::error::Error<>("decode: TPM2GetTime::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_164_);
        return ::futils::error::Error<>();
    }
    struct TPM2GetTimeResponse {
        std::uint32_t paramSize = 0;
        Bytes16 timeInfo;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2GetTimeResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).paramSize), true)) {
            return ::futils::error::Error<>("encode: TPM2GetTimeResponse::paramSize: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).timeInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2GetTimeResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).paramSize, true)) {
            return ::futils::error::Error<>("decode: TPM2GetTimeResponse::paramSize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).timeInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CreateLoaded {
        std::uint32_t parentHandle = 0;
        AuthCommand auth;
        TPMSensitiveCreate sensitive;
        TPMPublicKey public_;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2CreateLoaded::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).parentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2CreateLoaded::parentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).sensitive.encode(w)) {
            return err;
        }
        if (auto err = (*this).public_.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CreateLoaded::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).parentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2CreateLoaded::parentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).sensitive.decode(r)) {
            return err;
        }
        if (auto err = (*this).public_.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Load {
        std::uint32_t parentHandle = 0;
        AuthCommand auth;
        Bytes16 inPrivate;
        TPMPublicKey inPublic;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Load::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).parentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Load::parentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).inPrivate.encode(w)) {
            return err;
        }
        if (auto err = (*this).inPublic.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Load::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).parentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Load::parentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).inPrivate.decode(r)) {
            return err;
        }
        if (auto err = (*this).inPublic.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2LoadExternal {
        std::uint32_t parentHandle = 0;
        AuthCommand auth;
        std::uint16_t inPrivateSize = 0;
        struct union_struct_167 {
            InprivateForLoadExternal inPrivate;
        };
        std::variant<std::monostate, union_struct_167> union_variant_166;
        std::optional<InprivateForLoadExternal> inPrivate() const {
            if ((*this).inPrivateSize > 0 == true) {
                if (!std::holds_alternative<union_struct_167>(union_variant_166)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_166).inPrivate;
            }
            return std::nullopt;
        }
        bool inPrivate(const InprivateForLoadExternal& v) {
            if ((*this).inPrivateSize > 0 == true) {
                if (!std::holds_alternative<union_struct_167>(union_variant_166)) {
                    union_variant_166 = union_struct_167();
                }
                std::get<1>((*this).union_variant_166).inPrivate = v;
                return true;
            }
            return false;
        }
        TPMPublicKey inPublic;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2LoadExternal::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).parentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadExternal::parentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).inPrivateSize), true)) {
            return ::futils::error::Error<>("encode: TPM2LoadExternal::inPrivateSize: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if ((*this).inPrivateSize > 0) {
            if (!std::holds_alternative<union_struct_167>(union_variant_166)) {
                return ::futils::error::Error<>("encode: TPM2LoadExternal: union_variant_166 variant alternative union_struct_167 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<1>((*this).union_variant_166).inPrivate.encode(w)) {
                return err;
            }
        }
        if (auto err = (*this).inPublic.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2LoadExternal::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).parentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadExternal::parentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (!::futils::binary::read_num(r, (*this).inPrivateSize, true)) {
            return ::futils::error::Error<>("decode: TPM2LoadExternal::inPrivateSize: read int failed", ::futils::error::Category::lib);
        }
        if ((*this).inPrivateSize > 0) {
            if (!std::holds_alternative<union_struct_167>(union_variant_166)) {
                union_variant_166 = union_struct_167();
            }
            if (auto err = std::get<1>((*this).union_variant_166).inPrivate.decode(r)) {
                return err;
            }
        }
        if (auto err = (*this).inPublic.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2ECCParametersResponse {
        std::uint16_t curveID = 0;
        std::uint16_t keySize = 0;
        TPMScheme kdf;
        TPMScheme sign;
        Bytes16 p;
        Bytes16 a;
        Bytes16 b;
        ECCPoint g;
        Bytes16 n;
        Bytes16 h;
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2ECCParametersResponse::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).curveID), true)) {
            return ::futils::error::Error<>("encode: TPM2ECCParametersResponse::curveID: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>((*this).keySize), true)) {
            return ::futils::error::Error<>("encode: TPM2ECCParametersResponse::keySize: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).kdf.encode(w)) {
            return err;
        }
        if (auto err = (*this).sign.encode(w)) {
            return err;
        }
        if (auto err = (*this).p.encode(w)) {
            return err;
        }
        if (auto err = (*this).a.encode(w)) {
            return err;
        }
        if (auto err = (*this).b.encode(w)) {
            return err;
        }
        if (auto err = (*this).g.encode(w)) {
            return err;
        }
        if (auto err = (*this).n.encode(w)) {
            return err;
        }
        if (auto err = (*this).h.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2ECCParametersResponse::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).curveID, true)) {
            return ::futils::error::Error<>("decode: TPM2ECCParametersResponse::curveID: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).keySize, true)) {
            return ::futils::error::Error<>("decode: TPM2ECCParametersResponse::keySize: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).kdf.decode(r)) {
            return err;
        }
        if (auto err = (*this).sign.decode(r)) {
            return err;
        }
        if (auto err = (*this).p.decode(r)) {
            return err;
        }
        if (auto err = (*this).a.decode(r)) {
            return err;
        }
        if (auto err = (*this).b.decode(r)) {
            return err;
        }
        if (auto err = (*this).g.decode(r)) {
            return err;
        }
        if (auto err = (*this).n.decode(r)) {
            return err;
        }
        if (auto err = (*this).h.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CertifyCreate {
        std::uint32_t signHandle = 0;
        std::uint32_t objectHandle = 0;
        AuthCommand auth;
        Bytes16 qualifyingData;
        Bytes16 creationHash;
        TPMAlgorithmID schemeAlg{};
        TPMAlgorithmID hashAlg{};
        CreationTicket creationTicket;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 8;
    };
    inline ::futils::error::Error<> TPM2CertifyCreate::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2CertifyCreate::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).objectHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2CertifyCreate::objectHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.encode(w)) {
            return err;
        }
        if (auto err = (*this).creationHash.encode(w)) {
            return err;
        }
        auto tmp_168_ = static_cast<std::uint16_t>((*this).schemeAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_168_), true)) {
            return ::futils::error::Error<>("encode: TPM2CertifyCreate::schemeAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_169_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_169_), true)) {
            return ::futils::error::Error<>("encode: TPM2CertifyCreate::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).creationTicket.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CertifyCreate::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2CertifyCreate::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (!::futils::binary::read_num(r, (*this).objectHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2CertifyCreate::objectHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.decode(r)) {
            return err;
        }
        if (auto err = (*this).creationHash.decode(r)) {
            return err;
        }
        std::uint16_t tmp_170_ = 0;
        if (!::futils::binary::read_num(r, tmp_170_, true)) {
            return ::futils::error::Error<>("decode: TPM2CertifyCreate::schemeAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).schemeAlg = static_cast<TPMAlgorithmID>(tmp_170_);
        std::uint16_t tmp_171_ = 0;
        if (!::futils::binary::read_num(r, tmp_171_, true)) {
            return ::futils::error::Error<>("decode: TPM2CertifyCreate::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_171_);
        if (auto err = (*this).creationTicket.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Quote {
        std::uint32_t signHandle = 0;
        AuthCommand auth;
        Bytes16 qualifyingData;
        TPMAlgorithmID schemeAlg{};
        TPMAlgorithmID hashAlg{};
        PCR pcrSelect;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Quote::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Quote::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.encode(w)) {
            return err;
        }
        auto tmp_172_ = static_cast<std::uint16_t>((*this).schemeAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_172_), true)) {
            return ::futils::error::Error<>("encode: TPM2Quote::schemeAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        auto tmp_173_ = static_cast<std::uint16_t>((*this).hashAlg);
        if (!::futils::binary::write_num(w, static_cast<std::uint16_t>(tmp_173_), true)) {
            return ::futils::error::Error<>("encode: TPM2Quote::hashAlg: write std::uint16_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).pcrSelect.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Quote::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Quote::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).qualifyingData.decode(r)) {
            return err;
        }
        std::uint16_t tmp_174_ = 0;
        if (!::futils::binary::read_num(r, tmp_174_, true)) {
            return ::futils::error::Error<>("decode: TPM2Quote::schemeAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).schemeAlg = static_cast<TPMAlgorithmID>(tmp_174_);
        std::uint16_t tmp_175_ = 0;
        if (!::futils::binary::read_num(r, tmp_175_, true)) {
            return ::futils::error::Error<>("decode: TPM2Quote::hashAlg: read int failed", ::futils::error::Category::lib);
        }
        (*this).hashAlg = static_cast<TPMAlgorithmID>(tmp_175_);
        if (auto err = (*this).pcrSelect.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Commit {
        std::uint32_t signHandle = 0;
        AuthCommand auth;
        ECCPoint p1;
        Bytes16 s2_;
        ECCPoint y2;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Commit::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).signHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Commit::signHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).p1.encode(w)) {
            return err;
        }
        if (auto err = (*this).s2_.encode(w)) {
            return err;
        }
        if (auto err = (*this).y2.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Commit::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).signHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Commit::signHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).p1.decode(r)) {
            return err;
        }
        if (auto err = (*this).s2_.decode(r)) {
            return err;
        }
        if (auto err = (*this).y2.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2VerifySignature {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 digest;
        Signature signature;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2VerifySignature::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2VerifySignature::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).digest.encode(w)) {
            return err;
        }
        if (auto err = (*this).signature.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2VerifySignature::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2VerifySignature::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).digest.decode(r)) {
            return err;
        }
        if (auto err = (*this).signature.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Import {
        std::uint32_t parentHandle = 0;
        AuthCommand auth;
        Bytes16 encryptionKey;
        TPMPublicKey objectPublic;
        Bytes16 duplicate;
        Bytes16 inSymSeed;
        TPMSymetric symmetricAlg;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Import::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).parentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Import::parentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).encryptionKey.encode(w)) {
            return err;
        }
        if (auto err = (*this).objectPublic.encode(w)) {
            return err;
        }
        if (auto err = (*this).duplicate.encode(w)) {
            return err;
        }
        if (auto err = (*this).inSymSeed.encode(w)) {
            return err;
        }
        if (auto err = (*this).symmetricAlg.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Import::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).parentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Import::parentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).encryptionKey.decode(r)) {
            return err;
        }
        if (auto err = (*this).objectPublic.decode(r)) {
            return err;
        }
        if (auto err = (*this).duplicate.decode(r)) {
            return err;
        }
        if (auto err = (*this).inSymSeed.decode(r)) {
            return err;
        }
        if (auto err = (*this).symmetricAlg.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Sign {
        std::uint32_t keyHandle = 0;
        AuthCommand auth;
        Bytes16 digest;
        TPMScheme scheme;
        Validation validation;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Sign::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).keyHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Sign::keyHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).digest.encode(w)) {
            return err;
        }
        if (auto err = (*this).scheme.encode(w)) {
            return err;
        }
        if (auto err = (*this).validation.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Sign::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).keyHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Sign::keyHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).digest.decode(r)) {
            return err;
        }
        if (auto err = (*this).scheme.decode(r)) {
            return err;
        }
        if (auto err = (*this).validation.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2Create {
        std::uint32_t parentHandle = 0;
        AuthCommand auth;
        TPMSensitiveCreate sensitive;
        TPMPublicKey public_;
        Bytes16 outsideInfo;
        PCR creationPCR;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2Create::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).parentHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2Create::parentHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).sensitive.encode(w)) {
            return err;
        }
        if (auto err = (*this).public_.encode(w)) {
            return err;
        }
        if (auto err = (*this).outsideInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).creationPCR.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2Create::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).parentHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2Create::parentHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).sensitive.decode(r)) {
            return err;
        }
        if (auto err = (*this).public_.decode(r)) {
            return err;
        }
        if (auto err = (*this).outsideInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).creationPCR.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPM2CreatePrimary {
        std::uint32_t primaryHandle = 0;
        AuthCommand auth;
        TPMSensitiveCreate sensitive;
        TPMPublicKey public_;
        Bytes16 outsideInfo;
        PCR pcr;
        ::futils::error::Error<> encode(::futils::binary::writer& w, SessionState& session_state) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r, SessionState& session_state);
        static constexpr size_t fixed_header_size = 4;
    };
    inline ::futils::error::Error<> TPM2CreatePrimary::encode(::futils::binary::writer& w, SessionState& session_state) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).primaryHandle), true)) {
            return ::futils::error::Error<>("encode: TPM2CreatePrimary::primaryHandle: write std::uint32_t failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.encode(w, session_state)) {
            return err;
        }
        if (auto err = (*this).sensitive.encode(w)) {
            return err;
        }
        if (auto err = (*this).public_.encode(w)) {
            return err;
        }
        if (auto err = (*this).outsideInfo.encode(w)) {
            return err;
        }
        if (auto err = (*this).pcr.encode(w)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPM2CreatePrimary::decode(::futils::binary::reader& r, SessionState& session_state) {
        if (!::futils::binary::read_num(r, (*this).primaryHandle, true)) {
            return ::futils::error::Error<>("decode: TPM2CreatePrimary::primaryHandle: read int failed", ::futils::error::Category::lib);
        }
        if (auto err = (*this).auth.decode(r, session_state)) {
            return err;
        }
        if (auto err = (*this).sensitive.decode(r)) {
            return err;
        }
        if (auto err = (*this).public_.decode(r)) {
            return err;
        }
        if (auto err = (*this).outsideInfo.decode(r)) {
            return err;
        }
        if (auto err = (*this).pcr.decode(r)) {
            return err;
        }
        return ::futils::error::Error<>();
    }
    struct TPMAttest {
        TPMAttestHeader header;
        struct union_struct_178 {
            TPMAttestCerify certify;
        };
        struct union_struct_179 {
            TPMAttestCreation creation;
        };
        struct union_struct_180 {
            TPMAttestQuote quote;
        };
        struct union_struct_181 {
            TPMAttestCommandAudit command_audit;
        };
        struct union_struct_182 {
            TPMAttestSessionAudit session_audit;
        };
        struct union_struct_183 {
            TPMAttestTime time;
        };
        struct union_struct_184 {
            TPMAttestNV nv;
        };
        std::variant<std::monostate, union_struct_178, union_struct_179, union_struct_180, union_struct_181, union_struct_182, union_struct_183, union_struct_184> union_variant_177;
        std::optional<TPMAttestCerify> certify() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                if (!std::holds_alternative<union_struct_178>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<1>((*this).union_variant_177).certify;
            }
            return std::nullopt;
        }
        bool certify(const TPMAttestCerify& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                if (!std::holds_alternative<union_struct_178>(union_variant_177)) {
                    union_variant_177 = union_struct_178();
                }
                std::get<1>((*this).union_variant_177).certify = v;
                return true;
            }
            return false;
        }
        std::optional<TPMAttestCommandAudit> command_audit() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                if (!std::holds_alternative<union_struct_181>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<4>((*this).union_variant_177).command_audit;
            }
            return std::nullopt;
        }
        bool command_audit(const TPMAttestCommandAudit& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                if (!std::holds_alternative<union_struct_181>(union_variant_177)) {
                    union_variant_177 = union_struct_181();
                }
                std::get<4>((*this).union_variant_177).command_audit = v;
                return true;
            }
            return false;
        }
        std::optional<TPMAttestCreation> creation() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                if (!std::holds_alternative<union_struct_179>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<2>((*this).union_variant_177).creation;
            }
            return std::nullopt;
        }
        bool creation(const TPMAttestCreation& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                if (!std::holds_alternative<union_struct_179>(union_variant_177)) {
                    union_variant_177 = union_struct_179();
                }
                std::get<2>((*this).union_variant_177).creation = v;
                return true;
            }
            return false;
        }
        std::optional<TPMAttestNV> nv() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::TIME == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::NV == (*this).header.type) {
                if (!std::holds_alternative<union_struct_184>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<7>((*this).union_variant_177).nv;
            }
            return std::nullopt;
        }
        bool nv(const TPMAttestNV& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::TIME == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::NV == (*this).header.type) {
                if (!std::holds_alternative<union_struct_184>(union_variant_177)) {
                    union_variant_177 = union_struct_184();
                }
                std::get<7>((*this).union_variant_177).nv = v;
                return true;
            }
            return false;
        }
        std::optional<TPMAttestQuote> quote() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                if (!std::holds_alternative<union_struct_180>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<3>((*this).union_variant_177).quote;
            }
            return std::nullopt;
        }
        bool quote(const TPMAttestQuote& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                if (!std::holds_alternative<union_struct_180>(union_variant_177)) {
                    union_variant_177 = union_struct_180();
                }
                std::get<3>((*this).union_variant_177).quote = v;
                return true;
            }
            return false;
        }
        std::optional<TPMAttestSessionAudit> session_audit() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
                if (!std::holds_alternative<union_struct_182>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<5>((*this).union_variant_177).session_audit;
            }
            return std::nullopt;
        }
        bool session_audit(const TPMAttestSessionAudit& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
                if (!std::holds_alternative<union_struct_182>(union_variant_177)) {
                    union_variant_177 = union_struct_182();
                }
                std::get<5>((*this).union_variant_177).session_audit = v;
                return true;
            }
            return false;
        }
        std::optional<TPMAttestTime> time() const {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
                return std::nullopt;
            }
            if (TPMAttestType::TIME == (*this).header.type) {
                if (!std::holds_alternative<union_struct_183>(union_variant_177)) {
                    return std::nullopt;
                }
                return std::get<6>((*this).union_variant_177).time;
            }
            return std::nullopt;
        }
        bool time(const TPMAttestTime& v) {
            if (TPMAttestType::CERTIFY == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::CREATION == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::QUOTE == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
                return false;
            }
            if (TPMAttestType::TIME == (*this).header.type) {
                if (!std::holds_alternative<union_struct_183>(union_variant_177)) {
                    union_variant_177 = union_struct_183();
                }
                std::get<6>((*this).union_variant_177).time = v;
                return true;
            }
            return false;
        }
        ::futils::error::Error<> encode(::futils::binary::writer& w) const;
        ::futils::error::Error<> decode(::futils::binary::reader& r);
    };
    inline ::futils::error::Error<> TPMAttest::encode(::futils::binary::writer& w) const {
        if (auto err = (*this).header.encode(w)) {
            return err;
        }
        if (TPMAttestType::CERTIFY == (*this).header.type) {
            if (!std::holds_alternative<union_struct_178>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_178 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<1>((*this).union_variant_177).certify.encode(w)) {
                return err;
            }
        }
        else if (TPMAttestType::CREATION == (*this).header.type) {
            if (!std::holds_alternative<union_struct_179>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_179 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<2>((*this).union_variant_177).creation.encode(w)) {
                return err;
            }
        }
        else if (TPMAttestType::QUOTE == (*this).header.type) {
            if (!std::holds_alternative<union_struct_180>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_180 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<3>((*this).union_variant_177).quote.encode(w)) {
                return err;
            }
        }
        else if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
            if (!std::holds_alternative<union_struct_181>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_181 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<4>((*this).union_variant_177).command_audit.encode(w)) {
                return err;
            }
        }
        else if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
            if (!std::holds_alternative<union_struct_182>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_182 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<5>((*this).union_variant_177).session_audit.encode(w)) {
                return err;
            }
        }
        else if (TPMAttestType::TIME == (*this).header.type) {
            if (!std::holds_alternative<union_struct_183>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_183 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<6>((*this).union_variant_177).time.encode(w)) {
                return err;
            }
        }
        else if (TPMAttestType::NV == (*this).header.type) {
            if (!std::holds_alternative<union_struct_184>(union_variant_177)) {
                return ::futils::error::Error<>("encode: TPMAttest: union_variant_177 variant alternative union_struct_184 is not set", ::futils::error::Category::lib);
            }
            if (auto err = std::get<7>((*this).union_variant_177).nv.encode(w)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
    inline ::futils::error::Error<> TPMAttest::decode(::futils::binary::reader& r) {
        if (auto err = (*this).header.decode(r)) {
            return err;
        }
        if (TPMAttestType::CERTIFY == (*this).header.type) {
            if (!std::holds_alternative<union_struct_178>(union_variant_177)) {
                union_variant_177 = union_struct_178();
            }
            if (auto err = std::get<1>((*this).union_variant_177).certify.decode(r)) {
                return err;
            }
        }
        else if (TPMAttestType::CREATION == (*this).header.type) {
            if (!std::holds_alternative<union_struct_179>(union_variant_177)) {
                union_variant_177 = union_struct_179();
            }
            if (auto err = std::get<2>((*this).union_variant_177).creation.decode(r)) {
                return err;
            }
        }
        else if (TPMAttestType::QUOTE == (*this).header.type) {
            if (!std::holds_alternative<union_struct_180>(union_variant_177)) {
                union_variant_177 = union_struct_180();
            }
            if (auto err = std::get<3>((*this).union_variant_177).quote.decode(r)) {
                return err;
            }
        }
        else if (TPMAttestType::COMMAND_AUDIT == (*this).header.type) {
            if (!std::holds_alternative<union_struct_181>(union_variant_177)) {
                union_variant_177 = union_struct_181();
            }
            if (auto err = std::get<4>((*this).union_variant_177).command_audit.decode(r)) {
                return err;
            }
        }
        else if (TPMAttestType::SESSION_AUDIT == (*this).header.type) {
            if (!std::holds_alternative<union_struct_182>(union_variant_177)) {
                union_variant_177 = union_struct_182();
            }
            if (auto err = std::get<5>((*this).union_variant_177).session_audit.decode(r)) {
                return err;
            }
        }
        else if (TPMAttestType::TIME == (*this).header.type) {
            if (!std::holds_alternative<union_struct_183>(union_variant_177)) {
                union_variant_177 = union_struct_183();
            }
            if (auto err = std::get<6>((*this).union_variant_177).time.decode(r)) {
                return err;
            }
        }
        else if (TPMAttestType::NV == (*this).header.type) {
            if (!std::holds_alternative<union_struct_184>(union_variant_177)) {
                union_variant_177 = union_struct_184();
            }
            if (auto err = std::get<7>((*this).union_variant_177).nv.decode(r)) {
                return err;
            }
        }
        return ::futils::error::Error<>();
    }
}  // namespace futils::tpm2
