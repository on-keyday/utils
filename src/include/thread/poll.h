// Code generated by enumgen. DO NOT EDIT.
#pragma once
#include <cstddef>
#include <type_traits>
#include <utility>
#include <memory>
#include <error/error.h>
namespace futils::thread::poll {
    enum class ResultTag {
        Ok,
        Err,
    };
    template <typename T, typename E>
    struct Result {
        static constexpr size_t size = (sizeof(T) > sizeof(E)) ? sizeof(T) : sizeof(E);
        static constexpr size_t align = (alignof(T) > alignof(E)) ? alignof(T) : alignof(E);

       private:
        ResultTag tag;
        union {
            alignas(align) char data[size]{};
            T Ok_;
            E Err_;
        };
        void destruct() noexcept {
            switch (tag) {
                case ResultTag::Ok:
                    std::destroy_at(std::addressof(Ok_));
                    break;
                case ResultTag::Err:
                    std::destroy_at(std::addressof(Err_));
                    break;
            }
        }

       public:
        ~Result() noexcept {
            destruct();
        }
        struct Ok {
            T value;
        };
        Result(Ok Ok_)
            : tag(ResultTag::Ok) {
            new (data) T{std::move(Ok_.value)};
        }
        struct Err {
            E value;
        };
        Result(Err Err_)
            : tag(ResultTag::Err) {
            new (data) E{std::move(Err_.value)};
        }
        constexpr bool is_ok() const noexcept {
            return tag == ResultTag::Ok;
        }
        constexpr auto* ok() noexcept {
            return is_ok() ? std::addressof(Ok_) : nullptr;
        }
        constexpr bool is_err() const noexcept {
            return tag == ResultTag::Err;
        }
        constexpr auto* err() noexcept {
            return is_err() ? std::addressof(Err_) : nullptr;
        }
        constexpr ResultTag get_tag() const noexcept {
            return tag;
        }
        Result& operator=(Result&& other) noexcept {
            if (this == &other) return *this;
            destruct();
            tag = other.tag;
            switch (tag) {
                case ResultTag::Ok:
                    new (data) T{std::move(other.Ok_)};
                    break;
                case ResultTag::Err:
                    new (data) E{std::move(other.Err_)};
                    break;
            }
            return *this;
        }
    };
    enum class PollTag {
        Pending,
        Ready,
    };
    template <typename T>
    struct Poll {
        static constexpr size_t size = sizeof(T);
        static constexpr size_t align = alignof(T);

       private:
        PollTag tag;
        union {
            alignas(align) char data[size]{};
            T Ready_;
        };
        void destruct() noexcept {
            switch (tag) {
                case PollTag::Pending:
                    // nothing to destruct
                    break;
                case PollTag::Ready:
                    std::destroy_at(std::addressof(Ready_));
                    break;
            }
        }

       public:
        ~Poll() noexcept {
            destruct();
        }
        struct Pending {};
        Poll(Pending Pending_)
            : tag(PollTag::Pending) {}
        struct Ready {
            T value;
        };
        Poll(Ready Ready_)
            : tag(PollTag::Ready) {
            new (data) T{std::move(Ready_.value)};
        }
        constexpr bool is_pending() const noexcept {
            return tag == PollTag::Pending;
        }
        constexpr bool pending() const noexcept {
            return is_pending();
        }
        constexpr bool is_ready() const noexcept {
            return tag == PollTag::Ready;
        }
        constexpr auto* ready() noexcept {
            return is_ready() ? std::addressof(Ready_) : nullptr;
        }
        constexpr PollTag get_tag() const noexcept {
            return tag;
        }
        Poll& operator=(Poll&& other) noexcept {
            if (this == &other) return *this;
            destruct();
            tag = other.tag;
            switch (tag) {
                case PollTag::Pending:
                    break;
                case PollTag::Ready:
                    new (data) T{std::move(other.Ready_)};
                    break;
            }
            return *this;
        }
    };
    enum class TaskStateTag {
        Running,
        Finished,
        Consumed,
    };
    template <typename F, typename R>
    struct TaskState {
        static constexpr size_t size = (sizeof(F) > sizeof(Result<R, error::Error<>>)) ? sizeof(F) : sizeof(Result<R, error::Error<>>);
        static constexpr size_t align = (alignof(F) > alignof(Result<R, error::Error<>>)) ? alignof(F) : alignof(Result<R, error::Error<>>);

       private:
        TaskStateTag tag;
        union {
            alignas(align) char data[size]{};
            F Running_;
            Result<R, error::Error<>> Finished_;
        };
        void destruct() noexcept {
            switch (tag) {
                case TaskStateTag::Running:
                    std::destroy_at(std::addressof(Running_));
                    break;
                case TaskStateTag::Finished:
                    std::destroy_at(std::addressof(Finished_));
                    break;
                case TaskStateTag::Consumed:
                    // nothing to destruct
                    break;
            }
        }

       public:
        ~TaskState() noexcept {
            destruct();
        }
        struct Running {
            F value;
        };
        TaskState(Running Running_)
            : tag(TaskStateTag::Running) {
            new (data) F{std::move(Running_.value)};
        }
        struct Finished {
            Result<R, error::Error<>> value;
        };
        TaskState(Finished Finished_)
            : tag(TaskStateTag::Finished) {
            new (data) Result<R, error::Error<>>{std::move(Finished_.value)};
        }
        struct Consumed {};
        TaskState(Consumed Consumed_)
            : tag(TaskStateTag::Consumed) {}
        constexpr bool is_running() const noexcept {
            return tag == TaskStateTag::Running;
        }
        constexpr auto* running() noexcept {
            return is_running() ? std::addressof(Running_) : nullptr;
        }
        constexpr bool is_finished() const noexcept {
            return tag == TaskStateTag::Finished;
        }
        constexpr auto* finished() noexcept {
            return is_finished() ? std::addressof(Finished_) : nullptr;
        }
        constexpr bool is_consumed() const noexcept {
            return tag == TaskStateTag::Consumed;
        }
        constexpr bool consumed() const noexcept {
            return is_consumed();
        }
        constexpr TaskStateTag get_tag() const noexcept {
            return tag;
        }
        TaskState& operator=(TaskState&& other) noexcept {
            if (this == &other) return *this;
            destruct();
            tag = other.tag;
            switch (tag) {
                case TaskStateTag::Running:
                    new (data) F{std::move(other.Running_)};
                    break;
                case TaskStateTag::Finished:
                    new (data) Result<R, error::Error<>>{std::move(other.Finished_)};
                    break;
                case TaskStateTag::Consumed:
                    break;
            }
            return *this;
        }
    };
}  // namespace futils::thread::poll
