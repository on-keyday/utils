// Code generated by binred (https://github.com/on-keyday/utils)

#pragma once
#include <cstdint>
#include <string>

namespace uitls::net::http2 {
    struct H2Frame {
        int len;
        std::uint8_t type;
        std::uint8_t flag;
        std::int32_t id;
    };

    template <class Output>
    int encode(const H2Frame& input, Output& output) {
        output.write(input.len, 3);
        output.write(input.type);
        output.write(input.flag);
        if (!((input.id >= 0))) {
            return -1;
        }
        output.write(input.id);
        return 0;
    }

    template <class Input>
    int decode(Input&& input, H2Frame& output) {
        if (!input.read(output.len, 3)) {
            return -1;
        }
        if (!input.read(output.type)) {
            return -1;
        }
        if (!input.read(output.flag)) {
            return -1;
        }
        if (!input.read(output.id)) {
            return -1;
        }
        if (!((output.id >= 0))) {
            return -1;
        }
        return 0;
    }

    struct Priority {
        std::uint32_t depend = 0;
        std::uint8_t wight = 0;
    };

    template <class Output>
    bool encode(const Priority& input, Output& output) {
        output.write(input.depend);
        output.write(input.wight);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, Priority& output) {
        if (!input.read(output.depend)) {
            return false;
        }
        if (!input.read(output.wight)) {
            return false;
        }
        return true;
    }

    struct DataFrame : H2Frame {
        std::uint8_t padding = 0;
        std::string data;
        std::string pad;
    };

    template <class Output>
    bool encode(const DataFrame& input, Output& output) {
        if (!((input.type == 0))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if ((input.flag & 0x8)) {
            output.write(input.padding);
        }
        output.write(input.data, (input.len - input.padding));
        output.write(input.pad, input.padding);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, DataFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 0))) {
                return false;
            }
        }
        if ((output.flag & 0x8)) {
            if (!input.read(output.padding)) {
                return false;
            }
        }
        if (!input.read(output.data, (output.len - output.padding))) {
            return false;
        }
        if (!input.read(output.pad, output.padding)) {
            return false;
        }
        return true;
    }

    struct HeaderFrame : H2Frame {
        std::uint8_t padding = 0;
        Priority priority;
        std::string data;
        std::string pad;
    };

    template <class Output>
    bool encode(const HeaderFrame& input, Output& output) {
        if (!((input.type == 1))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if ((input.flag & 0x8)) {
            output.write(input.padding);
        }
        if ((input.flag & 0x20)) {
            if (auto e__ = encode(input.priority, output; !e__)) {
                return e__;
            }
        }
        output.write(input.data, (input.len - input.padding));
        output.write(input.pad, input.padding);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, HeaderFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 1))) {
                return false;
            }
        }
        if ((output.flag & 0x8)) {
            if (!input.read(output.padding)) {
                return false;
            }
        }
        if ((output.flag & 0x20)) {
            if (auto e__ = decode(input, output.priority; !e__)) {
                return e__;
            }
        }
        if (!input.read(output.data, (output.len - output.padding))) {
            return false;
        }
        if (!input.read(output.pad, output.padding)) {
            return false;
        }
        return true;
    }

    struct PriorityFrame : H2Frame {
        Priority priority;
    };

    template <class Output>
    bool encode(const PriorityFrame& input, Output& output) {
        if (!((input.len == 5))) {
            return false;
        }
        if (!((input.type == 2))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if (auto e__ = encode(input.priority, output; !e__)) {
            return e__;
        }
        return true;
    }

    template <class Input>
    bool decode(Input&& input, PriorityFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 2))) {
                return false;
            }
        }
        if (!((output.len == 5))) {
            return false;
        }
        if (auto e__ = decode(input, output.priority; !e__)) {
            return e__;
        }
        return true;
    }

    struct RstStreamFrame : H2Frame {
        std::uint32_t code;
    };

    template <class Output>
    bool encode(const RstStreamFrame& input, Output& output) {
        if (!((input.len == 4))) {
            return false;
        }
        if (!((input.type == 3))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        output.write(input.code);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, RstStreamFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 3))) {
                return false;
            }
        }
        if (!((output.len == 4))) {
            return false;
        }
        if (!input.read(output.code)) {
            return false;
        }
        return true;
    }

    struct SetingsFrame : H2Frame {
        std::string setting;
    };

    template <class Output>
    bool encode(const SetingsFrame& input, Output& output) {
        if (!(((input.len % 6) == 0))) {
            return false;
        }
        if (!((input.type == 4))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if ((input.flag & 0x1)) {
            output.write(input.setting, input.len);
        }
        return true;
    }

    template <class Input>
    bool decode(Input&& input, SetingsFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 4))) {
                return false;
            }
        }
        if (!(((output.len % 6) == 0))) {
            return false;
        }
        if ((output.flag & 0x1)) {
            if (!input.read(output.setting, output.len)) {
                return false;
            }
        }
        return true;
    }

    struct PushPromiseFrame : H2Frame {
        std::uint8_t padding = 0;
        std::int32_t promise;
        std::string data;
        std::string pad;
    };

    template <class Output>
    bool encode(const PushPromiseFrame& input, Output& output) {
        if (!((input.type == 5))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if ((input.flag & 0x8)) {
            output.write(input.padding);
        }
        if (!((input.promise > 0))) {
            return false;
        }
        output.write(input.promise);
        output.write(input.data, (input.len - input.padding));
        output.write(input.pad, input.padding);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, PushPromiseFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 5))) {
                return false;
            }
        }
        if ((output.flag & 0x8)) {
            if (!input.read(output.padding)) {
                return false;
            }
        }
        if (!input.read(output.promise)) {
            return false;
        }
        if (!((output.promise > 0))) {
            return false;
        }
        if (!input.read(output.data, (output.len - output.padding))) {
            return false;
        }
        if (!input.read(output.pad, output.padding)) {
            return false;
        }
        return true;
    }

    struct PingFrame : H2Frame {
        std::uint64_t opeque;
    };

    template <class Output>
    bool encode(const PingFrame& input, Output& output) {
        if (!((input.len == 8))) {
            return false;
        }
        if (!((input.type == 6))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if (!((input.id == 0))) {
            return false;
        }
        output.write(input.opeque);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, PingFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 6))) {
                return false;
            }
        }
        if (!((output.len == 8))) {
            return false;
        }
        if (!input.read(output.opeque)) {
            return false;
        }
        if (!((output.id == 0))) {
            return false;
        }
        return true;
    }

    struct GoAwayFrame : H2Frame {
        std::int32_t id;
        std::uint32_t code;
        std::string data;
    };

    template <class Output>
    bool encode(const GoAwayFrame& input, Output& output) {
        if (!((input.type == 7))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if (!((input.id >= 0))) {
            return false;
        }
        output.write(input.id);
        output.write(input.code);
        output.write(input.data, (input.len - 8));
        return true;
    }

    template <class Input>
    bool decode(Input&& input, GoAwayFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 7))) {
                return false;
            }
        }
        if (!input.read(output.id)) {
            return false;
        }
        if (!((output.id >= 0))) {
            return false;
        }
        if (!input.read(output.code)) {
            return false;
        }
        if (!input.read(output.data, (output.len - 8))) {
            return false;
        }
        return true;
    }

    struct WindowUpdateFrame : H2Frame {
        std::int32_t increment;
    };

    template <class Output>
    bool encode(const WindowUpdateFrame& input, Output& output) {
        if (!((input.len == 4))) {
            return false;
        }
        if (!((input.id > 0))) {
            return false;
        }
        if (!((input.type == 8))) {
            return false;
        }
        if (auto e__ = encode(static_cast<const H2Frame&>(input), output); !e__) {
            return e__;
        }
        if (!((input.increment > 0))) {
            return false;
        }
        output.write(input.increment);
        return true;
    }

    template <class Input>
    bool decode(Input&& input, WindowUpdateFrame& output, bool base_set = false) {
        if (!base_set) {
            if (auto e__ = decode(input, static_cast<H2Frame&>(output)); !e__) {
                return e__;
            }
            if (!((output.type == 8))) {
                return false;
            }
        }
        if (!((output.len == 4))) {
            return false;
        }
        if (!((output.id > 0))) {
            return false;
        }
        if (!input.read(output.increment)) {
            return false;
        }
        if (!((output.increment > 0))) {
            return false;
        }
        return true;
    }

}  // namespace uitls::net::http2
