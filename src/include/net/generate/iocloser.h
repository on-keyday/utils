/*
    utils - utility library
    Copyright (c) 2021-2022 on-keyday (https://github.com/on-keyday)
    Released under the MIT license
    https://opensource.org/licenses/mit-license.php
*/

// Code generated by ifacegen (https://github.com/on-keyday/utils)

#pragma once
#include"../../helper/deref.h"
#include<functional>
#include"../core/iodef.h"
#include"../../async/worker.h"

namespace utils {
namespace net {
struct IOClose {

   private:

    struct interface__ {
        virtual State write(const char* ptr, size_t size, size_t* written) = 0;
        virtual State read(char* ptr, size_t size, size_t* red) = 0;
        virtual State close(bool force) = 0;
        virtual const void* raw__(const std::type_info&) const noexcept = 0;

        virtual ~interface__() = default;
    };

    template<class T__>
    struct implements__ : interface__ {
        T__ t_holder_;

        template<class V__>
        implements__(V__&& args)
            :t_holder_(std::forward<V__>(args)){}

        State write(const char* ptr, size_t size, size_t* written) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                throw std::bad_function_call();
            }
            return t_ptr_->write(ptr, size, written);
        }

        State read(char* ptr, size_t size, size_t* red) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                throw std::bad_function_call();
            }
            return t_ptr_->read(ptr, size, red);
        }

        State close(bool force) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                throw std::bad_function_call();
            }
            return t_ptr_->close(force);
        }

        const void* raw__(const std::type_info&info__) const noexcept override {
            if (info__!=typeid(T__)) {
                return nullptr;
            }
            return static_cast<const void*>(std::addressof(t_holder_));
        }

    };

    interface__* iface = nullptr;

   public:
    constexpr IOClose(){}

    constexpr IOClose(std::nullptr_t){}

    template <class T__>
    IOClose(T__&& t) {
        static_assert(!std::is_same<std::decay_t<T__>,IOClose>::value,"can't accept same type");
        if(!utils::helper::deref(t)){
            return;
        }
        iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
    }

    constexpr IOClose(IOClose&& in) noexcept {
        iface=in.iface;
        in.iface=nullptr;
    }

    IOClose& operator=(IOClose&& in) noexcept {
        if(this==std::addressof(in))return *this;
        delete iface;
        iface=in.iface;
        in.iface=nullptr;
        return *this;
    }

    explicit operator bool() const noexcept {
        return iface != nullptr;
    }

    bool operator==(std::nullptr_t) const noexcept {
        return iface == nullptr;
    }
    
    ~IOClose() {
        delete iface;
    }

    State write(const char* ptr, size_t size, size_t* written) {
        return iface?iface->write(ptr, size, written):throw std::bad_function_call();
    }

    State read(char* ptr, size_t size, size_t* red) {
        return iface?iface->read(ptr, size, red):throw std::bad_function_call();
    }

    State close(bool force) {
        return iface?iface->close(force):throw std::bad_function_call();
    }

    template<class T__>
    const T__* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        return static_cast<const T__*>(iface->raw__(typeid(T__)));
    }

    template<class T__>
    T__* type_assert() {
        if (!iface) {
            return nullptr;
        }
        return static_cast<T__*>(const_cast<void*>(iface->raw__(typeid(T__))));
    }

    IOClose(const IOClose&) = delete;

    IOClose& operator=(const IOClose&) = delete;

    IOClose(IOClose&) = delete;

    IOClose& operator=(IOClose&) = delete;

};

struct IO {

   private:

    struct interface__ {
        virtual State write(const char* ptr, size_t size, size_t* written) = 0;
        virtual State read(char* ptr, size_t size, size_t* red) = 0;
        virtual const void* raw__(const std::type_info&) const noexcept = 0;

        virtual ~interface__() = default;
    };

    template<class T__>
    struct implements__ : interface__ {
        T__ t_holder_;

        template<class V__>
        implements__(V__&& args)
            :t_holder_(std::forward<V__>(args)){}

        State write(const char* ptr, size_t size, size_t* written) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                throw std::bad_function_call();
            }
            return t_ptr_->write(ptr, size, written);
        }

        State read(char* ptr, size_t size, size_t* red) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                throw std::bad_function_call();
            }
            return t_ptr_->read(ptr, size, red);
        }

        const void* raw__(const std::type_info&info__) const noexcept override {
            if (info__!=typeid(T__)) {
                return nullptr;
            }
            return static_cast<const void*>(std::addressof(t_holder_));
        }

    };

    interface__* iface = nullptr;

   public:
    constexpr IO(){}

    constexpr IO(std::nullptr_t){}

    template <class T__>
    IO(T__&& t) {
        static_assert(!std::is_same<std::decay_t<T__>,IO>::value,"can't accept same type");
        if(!utils::helper::deref(t)){
            return;
        }
        iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
    }

    constexpr IO(IO&& in) noexcept {
        iface=in.iface;
        in.iface=nullptr;
    }

    IO& operator=(IO&& in) noexcept {
        if(this==std::addressof(in))return *this;
        delete iface;
        iface=in.iface;
        in.iface=nullptr;
        return *this;
    }

    explicit operator bool() const noexcept {
        return iface != nullptr;
    }

    bool operator==(std::nullptr_t) const noexcept {
        return iface == nullptr;
    }
    
    ~IO() {
        delete iface;
    }

    State write(const char* ptr, size_t size, size_t* written) {
        return iface?iface->write(ptr, size, written):throw std::bad_function_call();
    }

    State read(char* ptr, size_t size, size_t* red) {
        return iface?iface->read(ptr, size, red):throw std::bad_function_call();
    }

    template<class T__>
    const T__* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        return static_cast<const T__*>(iface->raw__(typeid(T__)));
    }

    template<class T__>
    T__* type_assert() {
        if (!iface) {
            return nullptr;
        }
        return static_cast<T__*>(const_cast<void*>(iface->raw__(typeid(T__))));
    }

    IO(const IO&) = delete;

    IO& operator=(const IO&) = delete;

    IO(IO&) = delete;

    IO& operator=(IO&) = delete;

};

struct AsyncIOClose {

   private:

    struct interface__ {
        virtual async::Future<ReadInfo> read(char* ptr, size_t size) = 0;
        virtual async::Future<WriteInfo> write(const char* ptr, size_t size) = 0;
        virtual State close(bool force) = 0;
        virtual const void* raw__(const std::type_info&) const noexcept = 0;

        virtual ~interface__() = default;
    };

    template<class T__>
    struct implements__ : interface__ {
        T__ t_holder_;

        template<class V__>
        implements__(V__&& args)
            :t_holder_(std::forward<V__>(args)){}

        async::Future<ReadInfo> read(char* ptr, size_t size) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return async::Future<ReadInfo>{};
            }
            return t_ptr_->read(ptr, size);
        }

        async::Future<WriteInfo> write(const char* ptr, size_t size) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return async::Future<WriteInfo>{};
            }
            return t_ptr_->write(ptr, size);
        }

        State close(bool force) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return State{};
            }
            return t_ptr_->close(force);
        }

        const void* raw__(const std::type_info&info__) const noexcept override {
            if (info__!=typeid(T__)) {
                return nullptr;
            }
            return static_cast<const void*>(std::addressof(t_holder_));
        }

    };

    interface__* iface = nullptr;

   public:
    constexpr AsyncIOClose(){}

    constexpr AsyncIOClose(std::nullptr_t){}

    template <class T__>
    AsyncIOClose(T__&& t) {
        static_assert(!std::is_same<std::decay_t<T__>,AsyncIOClose>::value,"can't accept same type");
        if(!utils::helper::deref(t)){
            return;
        }
        iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
    }

    constexpr AsyncIOClose(AsyncIOClose&& in) noexcept {
        iface=in.iface;
        in.iface=nullptr;
    }

    AsyncIOClose& operator=(AsyncIOClose&& in) noexcept {
        if(this==std::addressof(in))return *this;
        delete iface;
        iface=in.iface;
        in.iface=nullptr;
        return *this;
    }

    explicit operator bool() const noexcept {
        return iface != nullptr;
    }

    bool operator==(std::nullptr_t) const noexcept {
        return iface == nullptr;
    }
    
    ~AsyncIOClose() {
        delete iface;
    }

    async::Future<ReadInfo> read(char* ptr, size_t size) {
        return iface?iface->read(ptr, size):async::Future<ReadInfo>{};
    }

    async::Future<WriteInfo> write(const char* ptr, size_t size) {
        return iface?iface->write(ptr, size):async::Future<WriteInfo>{};
    }

    State close(bool force) {
        return iface?iface->close(force):State{};
    }

    template<class T__>
    const T__* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        return static_cast<const T__*>(iface->raw__(typeid(T__)));
    }

    template<class T__>
    T__* type_assert() {
        if (!iface) {
            return nullptr;
        }
        return static_cast<T__*>(const_cast<void*>(iface->raw__(typeid(T__))));
    }

    AsyncIOClose(const AsyncIOClose&) = delete;

    AsyncIOClose& operator=(const AsyncIOClose&) = delete;

    AsyncIOClose(AsyncIOClose&) = delete;

    AsyncIOClose& operator=(AsyncIOClose&) = delete;

};

} // namespace net
} // namespace utils
