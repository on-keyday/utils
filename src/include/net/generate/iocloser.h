/*
    utils - utility library
    Copyright (c) 2021 on-keyday (https://github.com/on-keyday)
    Released under the MIT license
    https://opensource.org/licenses/mit-license.php
*/

// Code generated by ifacegen (https://github.com/on-keyday/utils)

#pragma once
#include"../../helper/deref.h"
#include"../core/iodef.h"

#ifndef NOVTABLE__
#ifdef _WIN32
#define NOVTABLE__ __declspec(novtable)
#else
#define NOVTABLE__
#endif
#endif

namespace utils::net {
struct IOClose {
   private:
    struct NOVTABLE__ interface__ {
        virtual State write(const char* ptr, size_t size) = 0;
        virtual State read(char* ptr, size_t size, size_t* red) = 0;
        virtual State close(bool force) = 0;
        virtual const void* raw__() const = 0;
        virtual const std::type_info& type__() const = 0;
    
        virtual ~interface__(){}
    };
    
    template<class T>
    struct implements__ : interface__ {
        T t_holder_;

        template<class... Args>
        implements__(Args&&...args)
            :t_holder_(std::forward<Args>(args)...){}

        State write(const char* ptr, size_t size) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return State::undefined;
            }
            return t_ptr_->write(ptr, size);
        }

        State read(char* ptr, size_t size, size_t* red) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return State::undefined;
            }
            return t_ptr_->read(ptr, size, red);
        }

        State close(bool force) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return State::undefined;
            }
            return t_ptr_->close(force);
        }

        const void* raw__() const override {   
            return reinterpret_cast<const void*>(std::addressof(t_holder_));
        }
        
        const std::type_info& type__() const override {
            return typeid(T);
        }

    };

    interface__* iface = nullptr;

   public:
    constexpr IOClose(){}

    constexpr IOClose(std::nullptr_t){}

    template <class T>
    IOClose(T&& t) {
        if(!utils::helper::deref(t)){
            return;
        }
        iface=new implements__<std::decay_t<T>>(std::forward<T>(t));
    }
    
    IOClose(IOClose&& in) {
        iface=in.iface;
        in.iface=nullptr;
    }
    
    IOClose& operator=(IOClose&& in) {
        delete iface;
        iface=in.iface;
        in.iface=nullptr;
        return *this;
    }

    explicit operator bool() const {
        return iface != nullptr;
    }

    ~IOClose() {
        delete iface;
    }

    State write(const char* ptr, size_t size) {
        return iface?iface->write(ptr, size):State::undefined;
    }

    State read(char* ptr, size_t size, size_t* red) {
        return iface?iface->read(ptr, size, red):State::undefined;
    }

    State close(bool force) {
        return iface?iface->close(force):State::undefined;
    }

    template<class T>
    const T* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T)) {
            return nullptr;
        }
        return reinterpret_cast<const T*>(iface->raw__());
    }
    
    template<class T>
    T* type_assert() {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T)) {
                        return nullptr;
                }
                return reinterpret_cast<T*>(const_cast<void*>(iface->raw__()));
            }

};

struct IO {
   private:
    struct NOVTABLE__ interface__ {
        virtual State write(const char* ptr, size_t size) = 0;
        virtual State read(char* ptr, size_t size, size_t* red) = 0;
        virtual const void* raw__() const = 0;
        virtual const std::type_info& type__() const = 0;
    
        virtual ~interface__(){}
    };
    
    template<class T>
    struct implements__ : interface__ {
        T t_holder_;

        template<class... Args>
        implements__(Args&&...args)
            :t_holder_(std::forward<Args>(args)...){}

        State write(const char* ptr, size_t size) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return State::undefined;
            }
            return t_ptr_->write(ptr, size);
        }

        State read(char* ptr, size_t size, size_t* red) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return State::undefined;
            }
            return t_ptr_->read(ptr, size, red);
        }

        const void* raw__() const override {   
            return reinterpret_cast<const void*>(std::addressof(t_holder_));
        }
        
        const std::type_info& type__() const override {
            return typeid(T);
        }

    };

    interface__* iface = nullptr;

   public:
    constexpr IO(){}

    constexpr IO(std::nullptr_t){}

    template <class T>
    IO(T&& t) {
        if(!utils::helper::deref(t)){
            return;
        }
        iface=new implements__<std::decay_t<T>>(std::forward<T>(t));
    }
    
    IO(IO&& in) {
        iface=in.iface;
        in.iface=nullptr;
    }
    
    IO& operator=(IO&& in) {
        delete iface;
        iface=in.iface;
        in.iface=nullptr;
        return *this;
    }

    explicit operator bool() const {
        return iface != nullptr;
    }

    ~IO() {
        delete iface;
    }

    State write(const char* ptr, size_t size) {
        return iface?iface->write(ptr, size):State::undefined;
    }

    State read(char* ptr, size_t size, size_t* red) {
        return iface?iface->read(ptr, size, red):State::undefined;
    }

    template<class T>
    const T* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T)) {
            return nullptr;
        }
        return reinterpret_cast<const T*>(iface->raw__());
    }
    
    template<class T>
    T* type_assert() {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T)) {
                        return nullptr;
                }
                return reinterpret_cast<T*>(const_cast<void*>(iface->raw__()));
            }

};

} // namespace utils::net
