/*
    utils - utility library
    Copyright (c) 2021-2023 on-keyday (https://github.com/on-keyday)
    Released under the MIT license
    https://opensource.org/licenses/mit-license.php
*/

// Code generated by ifacegen (https://github.com/on-keyday/utils)

#pragma once
#include <helper/deref.h>
#include "../matching/state.h"

#ifndef NOVTABLE__
#ifdef _WIN32
#define NOVTABLE__ __declspec(novtable)
#else
#define NOVTABLE__
#endif
#endif

namespace utils {
    namespace syntax {
        template <typename T>
        struct Filter {
           private:
            struct NOVTABLE__ interface__ {
                virtual bool operator()(T& ctx) = 0;
                virtual interface__* copy__() const = 0;

                virtual ~interface__() = default;
            };

            template <class T__>
            struct implements__ : interface__ {
                T__ t_holder_;

                template <class V__>
                implements__(V__&& args)
                    : t_holder_(std::forward<V__>(args)) {}

                bool operator()(T& ctx) override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        return false;
                    }
                    return (*t_ptr_)(ctx);
                }

                interface__* copy__() const override {
                    return new implements__<T__>(t_holder_);
                }
            };

            interface__* iface = nullptr;

           public:
            constexpr Filter() {}

            constexpr Filter(std::nullptr_t) {}

            template <class T__>
            Filter(T__&& t) {
                static_assert(!std::is_same<std::decay_t<T__>, Filter>::value, "can't accept same type");
                if (!utils::helper::deref(t)) {
                    return;
                }
                iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
            }

            constexpr Filter(Filter&& in) noexcept {
                iface = in.iface;
                in.iface = nullptr;
            }

            Filter& operator=(Filter&& in) noexcept {
                if (this == std::addressof(in)) return *this;
                delete iface;
                iface = in.iface;
                in.iface = nullptr;
                return *this;
            }

            explicit operator bool() const noexcept {
                return iface != nullptr;
            }

            bool operator==(std::nullptr_t) const noexcept {
                return iface == nullptr;
            }

            ~Filter() {
                delete iface;
            }

            bool operator()(T& ctx) {
                return iface ? iface->operator()(ctx) : false;
            }

            Filter(const Filter& in) {
                if (in.iface) {
                    iface = in.iface->copy__();
                }
            }

            Filter& operator=(const Filter& in) {
                if (std::addressof(in) == this) return *this;
                delete iface;
                iface = nullptr;
                if (in.iface) {
                    iface = in.iface->copy__();
                }
                return *this;
            }

            Filter(Filter& in)
                : Filter(const_cast<const Filter&>(in)) {}

            Filter& operator=(Filter& in) {
                return *this = const_cast<const Filter&>(in);
            }
        };

        template <typename T>
        struct Dispatch {
           private:
            struct NOVTABLE__ interface__ {
                virtual MatchState operator()(T& ctx, bool cancel) = 0;
                virtual interface__* copy__() const = 0;

                virtual ~interface__() = default;
            };

            template <class T__>
            struct implements__ : interface__ {
                T__ t_holder_;

                template <class V__>
                implements__(V__&& args)
                    : t_holder_(std::forward<V__>(args)) {}

                MatchState operator()(T& ctx, bool cancel) override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        return MatchState::succeed;
                    }
                    return (*t_ptr_)(ctx, cancel);
                }

                interface__* copy__() const override {
                    return new implements__<T__>(t_holder_);
                }
            };

            interface__* iface = nullptr;

           public:
            constexpr Dispatch() {}

            constexpr Dispatch(std::nullptr_t) {}

            template <class T__>
            Dispatch(T__&& t) {
                static_assert(!std::is_same<std::decay_t<T__>, Dispatch>::value, "can't accept same type");
                if (!utils::helper::deref(t)) {
                    return;
                }
                iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
            }

            constexpr Dispatch(Dispatch&& in) noexcept {
                iface = in.iface;
                in.iface = nullptr;
            }

            Dispatch& operator=(Dispatch&& in) noexcept {
                if (this == std::addressof(in)) return *this;
                delete iface;
                iface = in.iface;
                in.iface = nullptr;
                return *this;
            }

            explicit operator bool() const noexcept {
                return iface != nullptr;
            }

            bool operator==(std::nullptr_t) const noexcept {
                return iface == nullptr;
            }

            ~Dispatch() {
                delete iface;
            }

            MatchState operator()(T& ctx, bool cancel) {
                return iface ? iface->operator()(ctx, cancel) : MatchState::succeed;
            }

            Dispatch(const Dispatch& in) {
                if (in.iface) {
                    iface = in.iface->copy__();
                }
            }

            Dispatch& operator=(const Dispatch& in) {
                if (std::addressof(in) == this) return *this;
                delete iface;
                iface = nullptr;
                if (in.iface) {
                    iface = in.iface->copy__();
                }
                return *this;
            }

            Dispatch(Dispatch& in)
                : Dispatch(const_cast<const Dispatch&>(in)) {}

            Dispatch& operator=(Dispatch& in) {
                return *this = const_cast<const Dispatch&>(in);
            }
        };

    }  // namespace syntax
}  // namespace utils
