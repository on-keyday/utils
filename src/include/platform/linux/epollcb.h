/*
    utils - utility library
    Copyright (c) 2021-2022 on-keyday (https://github.com/on-keyday)
    Released under the MIT license
    https://opensource.org/licenses/mit-license.php
*/

// Code generated by ifacegen (https://github.com/on-keyday/utils)

#pragma once
#include <cstddef>
#include "../../helper/deref.h"

#ifndef NOVTABLE__
#ifdef _WIN32
#define NOVTABLE__ __declspec(novtable)
#else
#define NOVTABLE__
#endif
#endif

namespace utils {
    namespace platform {
        namespace linuxd {
            struct EpollCallback {
               private:
                struct vtable__t {
                    bool (*call)(void* this__, void* ptr, std::uint32_t events) = nullptr;
                };

                template <class T__v>
                struct vtable__instance__ {
                   private:
                    constexpr vtable__instance__() = default;
                    using this_type = std::remove_pointer_t<decltype(utils::helper::deref(std::declval<std::decay_t<T__v>&>()))>;

                    static bool call(void* this__, void* ptr, std::uint32_t events) {
                        return static_cast<this_type*>(this__)->call(ptr, events);
                    }

                   public:
                    static const vtable__t* instantiate() noexcept {
                        static vtable__t instance{
                            &vtable__instance__::call,
                        };
                        return &instance;
                    }
                };

               public:
                struct vtable__interface__ {
                   private:
                    void* this__ = nullptr;
                    const vtable__t* vtable__ = nullptr;

                   public:
                    constexpr vtable__interface__() = default;

                    explicit operator bool() const {
                        return this__ != nullptr && vtable__ != nullptr;
                    }

                    const vtable__t* to_c_style_vtable() const {
                        return vtable__;
                    }

                    void* to_c_style_this() const {
                        return this__;
                    }

                    template <class T__v>
                    vtable__interface__(T__v&& v__)
                        : this__(static_cast<void*>(utils::helper::deref(v__))), vtable__(vtable__instance__<T__v>::instantiate()) {}

                    bool call(void* ptr, std::uint32_t events) {
                        return vtable__->call(this__, ptr, events);
                    }
                };

               private:
                struct NOVTABLE__ interface__ {
                    virtual bool call(void* ptr, std::uint32_t events) = 0;
                    virtual vtable__interface__ vtable__get__() const noexcept = 0;
                    virtual interface__* move__(void* __storage_box) = 0;

                    virtual ~interface__() = default;
                };

                template <class T__>
                struct implements__ : interface__ {
                    T__ t_holder_;

                    template <class V__>
                    implements__(V__&& args)
                        : t_holder_(std::forward<V__>(args)) {}

                    bool call(void* ptr, std::uint32_t events) override {
                        auto t_ptr_ = utils::helper::deref(this->t_holder_);
                        if (!t_ptr_) {
                            return bool{};
                        }
                        return t_ptr_->call(ptr, events);
                    }

                    vtable__interface__ vtable__get__() const noexcept override {
                        return vtable__interface__(const_cast<T__&>(t_holder_));
                    }

                    interface__* move__(void* __storage_box) override {
                        using gen_type = implements__<T__>;
                        if constexpr (sizeof(gen_type) <= sizeof(void*) * 3 &&
                                      alignof(gen_type) <= alignof(std::max_align_t) &&
                                      std::is_nothrow_move_constructible<T__>::value) {
                            return new (__storage_box) implements__<T__>(std::move(t_holder_));
                        }
                        else {
                            return nullptr;
                        }
                    }
                };

                union {
                    char __storage_box[sizeof(void*) * (1 + (3))]{0};
                    std::max_align_t __align_of;
                    struct {
                        void* __place_holder[3];
                        interface__* iface;
                    };
                };

                template <class T__>
                void new___(T__&& v) {
                    interface__* p = nullptr;
                    using decay_T__ = std::decay_t<T__>;
                    using gen_type = implements__<decay_T__>;
                    if constexpr (sizeof(gen_type) <= sizeof(void*) * 3 &&
                                  alignof(gen_type) <= alignof(std::max_align_t) &&
                                  std::is_nothrow_move_constructible<decay_T__>::value) {
                        p = new (__storage_box) gen_type(std::forward<T__>(v));
                    }
                    else {
                        p = new gen_type(std::forward<T__>(v));
                    }
                    iface = p;
                }

                bool is_local___() const {
                    return static_cast<const void*>(__storage_box) == static_cast<const void*>(iface);
                }

                void delete___() {
                    if (!iface) return;
                    if (!is_local___()) {
                        delete iface;
                    }
                    else {
                        iface->~interface__();
                    }
                    iface = nullptr;
                }

               public:
                constexpr EpollCallback() {}

                constexpr EpollCallback(std::nullptr_t) {}

                template <class T__>
                EpollCallback(T__&& t) {
                    static_assert(!std::is_same<std::decay_t<T__>, EpollCallback>::value, "can't accept same type");
                    if (!utils::helper::deref(t)) {
                        return;
                    }
                    new___(std::forward<T__>(t));
                }

                EpollCallback(EpollCallback&& in) noexcept {
                    // reference implementation: MSVC std::function
                    if (in.is_local___()) {
                        iface = in.iface->move__(__storage_box);
                        in.delete___();
                    }
                    else {
                        iface = in.iface;
                        in.iface = nullptr;
                    }
                }

                EpollCallback& operator=(EpollCallback&& in) noexcept {
                    if (this == std::addressof(in)) return *this;
                    delete___();
                    // reference implementation: MSVC std::function
                    if (in.is_local___()) {
                        iface = in.iface->move__(__storage_box);
                        in.delete___();
                    }
                    else {
                        iface = in.iface;
                        in.iface = nullptr;
                    }
                    return *this;
                }

                explicit operator bool() const noexcept {
                    return iface != nullptr;
                }

                bool operator==(std::nullptr_t) const noexcept {
                    return iface == nullptr;
                }

                ~EpollCallback() {
                    delete___();
                }

                bool call(void* ptr, std::uint32_t events) {
                    return iface ? iface->call(ptr, events) : bool{};
                }

                vtable__interface__ get_self_vtable() const noexcept {
                    return iface ? iface->vtable__get__() : vtable__interface__{};
                }

                template <class T__v>
                static vtable__interface__ get_vtable(T__v& v) noexcept {
                    return vtable__interface__(v);
                }

                EpollCallback(const EpollCallback&) = delete;

                EpollCallback& operator=(const EpollCallback&) = delete;

                EpollCallback(EpollCallback&) = delete;

                EpollCallback& operator=(EpollCallback&) = delete;
            };

            using EpollCb = decltype(std::declval<EpollCallback>().get_self_vtable());

        }  // namespace linuxd
    }      // namespace platform
}  // namespace utils
