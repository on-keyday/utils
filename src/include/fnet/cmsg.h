// Code generated by json2cpp2
#pragma once
#include <cstdint>
#include <vector>
#include <array>
#include <optional>
#include <variant>

#include <binary/flags.h>
#include <binary/float.h>
#include <view/iovec.h>
#include <binary/number.h>
namespace futils::fnet {
    struct CMsg {
        std::uint64_t len = 0;
        std::uint32_t level = 0;
        std::uint32_t type = 0;
        ::futils::view::rvec msg;
        constexpr bool encode(::futils::binary::writer& w) const;
        constexpr bool decode(::futils::binary::reader& r);
        static constexpr size_t fixed_header_size = 16;
    };
    constexpr inline bool CMsg::encode(::futils::binary::writer& w) const {
        if (!::futils::binary::write_num(w, static_cast<std::uint64_t>((*this).len), false)) {
            return false;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).level), false)) {
            return false;
        }
        if (!::futils::binary::write_num(w, static_cast<std::uint32_t>((*this).type), false)) {
            return false;
        }
        if (!((*this).len >= 16)) {
            return false;
        }
        auto tmp_0_ = (*this).len - 16;
        if (tmp_0_ != (*this).msg.size()) {
            return false;
        }
        if (!w.write((*this).msg)) {
            return false;
        }
        return true;
    }
    constexpr inline bool CMsg::decode(::futils::binary::reader& r) {
        if (!::futils::binary::read_num(r, (*this).len, false)) {
            return false;
        }
        if (!::futils::binary::read_num(r, (*this).level, false)) {
            return false;
        }
        if (!::futils::binary::read_num(r, (*this).type, false)) {
            return false;
        }
        if (!((*this).len >= 16)) {
            return false;
        }
        auto tmp_1_ = (*this).len - 16;
        if (!r.read((*this).msg, tmp_1_)) {
            return false;
        }
        return true;
    }
}  // namespace futils::fnet
