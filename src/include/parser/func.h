/*
    utils - utility library
    Copyright (c) 2021-2022 on-keyday (https://github.com/on-keyday)
    Released under the MIT license
    https://opensource.org/licenses/mit-license.php
*/

// Code generated by ifacegen (https://github.com/on-keyday/utils)

#pragma once
#include "../helper/deref.h"
#include <functional>
#include "parser_base.h"

namespace utils {
    namespace parser {
        template <typename Input, typename String, typename Kind, template <typename...> typename Vec>
        struct Func {
           private:
            struct interface__ {
                virtual bool operator()(Sequencer<Input>& seq, wrap::shared_ptr<Token<String, Kind, Vec>>& tok, int flag, Pos& pos) = 0;
                virtual const void* raw__() const = 0;
                virtual const std::type_info& type__() const = 0;

                virtual ~interface__() {}
            };

            template <class T__>
            struct implements__ : interface__ {
                T__ t_holder_;

                template <class V__>
                implements__(V__&& args)
                    : t_holder_(std::forward<V__>(args)) {}

                bool operator()(Sequencer<Input>& seq, wrap::shared_ptr<Token<String, Kind, Vec>>& tok, int flag, Pos& pos) override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        throw std::bad_function_call();
                    }
                    return (*t_ptr_)(seq, tok, flag, pos);
                }

                const void* raw__() const override {
                    return reinterpret_cast<const void*>(std::addressof(t_holder_));
                }

                const std::type_info& type__() const override {
                    return typeid(T__);
                }
            };

            interface__* iface = nullptr;

           public:
            constexpr Func() {}

            constexpr Func(std::nullptr_t) {}

            template <class T__>
            Func(T__&& t) {
                if (!utils::helper::deref(t)) {
                    return;
                }
                iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
            }

            Func(Func&& in) {
                iface = in.iface;
                in.iface = nullptr;
            }

            Func& operator=(Func&& in) {
                delete iface;
                iface = in.iface;
                in.iface = nullptr;
                return *this;
            }

            explicit operator bool() const {
                return iface != nullptr;
            }

            ~Func() {
                delete iface;
            }

            bool operator()(Sequencer<Input>& seq, wrap::shared_ptr<Token<String, Kind, Vec>>& tok, int flag, Pos& pos) {
                return iface ? iface->operator()(seq, tok, flag, pos) : throw std::bad_function_call();
            }

            template <class T__>
            const T__* type_assert() const {
                if (!iface) {
                    return nullptr;
                }
                if (iface->type__() != typeid(T__)) {
                    return nullptr;
                }
                return reinterpret_cast<const T__*>(iface->raw__());
            }

            template <class T__>
            T__* type_assert() {
                if (!iface) {
                    return nullptr;
                }
                if (iface->type__() != typeid(T__)) {
                    return nullptr;
                }
                return reinterpret_cast<T__*>(const_cast<void*>(iface->raw__()));
            }
        };

        template <typename Input, typename String, typename Kind, template <typename...> typename Vec>
        struct IParser {
           private:
            struct interface__ {
                virtual wrap::shared_ptr<Token<String, Kind, Vec>> parse(Sequencer<Input>& seq, Pos& pos) = 0;
                virtual bool none_is_not_error() const = 0;
                virtual ParserKind declkind() const = 0;
                virtual const void* raw__() const = 0;
                virtual const std::type_info& type__() const = 0;

                virtual ~interface__() {}
            };

            template <class T__>
            struct implements__ : interface__ {
                T__ t_holder_;

                template <class V__>
                implements__(V__&& args)
                    : t_holder_(std::forward<V__>(args)) {}

                wrap::shared_ptr<Token<String, Kind, Vec>> parse(Sequencer<Input>& seq, Pos& pos) override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        return wrap::shared_ptr<Token<String, Kind, Vec>>{};
                    }
                    return t_ptr_->parse(seq, pos);
                }

                bool none_is_not_error() const override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        return bool{};
                    }
                    return t_ptr_->none_is_not_error();
                }

                ParserKind declkind() const override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        return ParserKind{};
                    }
                    return t_ptr_->declkind();
                }

                const void* raw__() const override {
                    return reinterpret_cast<const void*>(std::addressof(t_holder_));
                }

                const std::type_info& type__() const override {
                    return typeid(T__);
                }
            };

            interface__* iface = nullptr;

           public:
            constexpr IParser() {}

            constexpr IParser(std::nullptr_t) {}

            template <class T__>
            IParser(T__&& t) {
                if (!utils::helper::deref(t)) {
                    return;
                }
                iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
            }

            IParser(IParser&& in) {
                iface = in.iface;
                in.iface = nullptr;
            }

            IParser& operator=(IParser&& in) {
                delete iface;
                iface = in.iface;
                in.iface = nullptr;
                return *this;
            }

            explicit operator bool() const {
                return iface != nullptr;
            }

            ~IParser() {
                delete iface;
            }

            wrap::shared_ptr<Token<String, Kind, Vec>> parse(Sequencer<Input>& seq, Pos& pos) {
                return iface ? iface->parse(seq, pos) : wrap::shared_ptr<Token<String, Kind, Vec>>{};
            }

            bool none_is_not_error() const {
                return iface ? iface->none_is_not_error() : bool{};
            }

            ParserKind declkind() const {
                return iface ? iface->declkind() : ParserKind{};
            }

            template <class T__>
            const T__* type_assert() const {
                if (!iface) {
                    return nullptr;
                }
                if (iface->type__() != typeid(T__)) {
                    return nullptr;
                }
                return reinterpret_cast<const T__*>(iface->raw__());
            }

            template <class T__>
            T__* type_assert() {
                if (!iface) {
                    return nullptr;
                }
                if (iface->type__() != typeid(T__)) {
                    return nullptr;
                }
                return reinterpret_cast<T__*>(const_cast<void*>(iface->raw__()));
            }
        };

        template <typename string>
        struct error {
           private:
            struct interface__ {
                virtual string Error() = 0;

                virtual ~interface__() {}
            };

            template <class T__>
            struct implements__ : interface__ {
                T__ t_holder_;

                template <class V__>
                implements__(V__&& args)
                    : t_holder_(std::forward<V__>(args)) {}

                string Error() override {
                    auto t_ptr_ = utils::helper::deref(this->t_holder_);
                    if (!t_ptr_) {
                        return string{};
                    }
                    return t_ptr_->Error();
                }
            };

            interface__* iface = nullptr;

           public:
            constexpr error() {}

            constexpr error(std::nullptr_t) {}

            template <class T__>
            error(T__&& t) {
                if (!utils::helper::deref(t)) {
                    return;
                }
                iface = new implements__<std::decay_t<T__>>(std::forward<T__>(t));
            }

            error(error&& in) {
                iface = in.iface;
                in.iface = nullptr;
            }

            error& operator=(error&& in) {
                delete iface;
                iface = in.iface;
                in.iface = nullptr;
                return *this;
            }

            explicit operator bool() const {
                return iface != nullptr;
            }

            ~error() {
                delete iface;
            }

            string Error() {
                return iface ? iface->Error() : string{};
            }
        };

    }  // namespace parser
}  // namespace utils
