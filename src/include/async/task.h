/*
    utils - utility library
    Copyright (c) 2021-2023 on-keyday (https://github.com/on-keyday)
    Released under the MIT license
    https://opensource.org/licenses/mit-license.php
*/

// Code generated by ifacegen (https://github.com/on-keyday/utils)

#pragma once
#include<cstddef>
#include"../helper/deref.h"

#ifndef NOVTABLE__
#ifdef _WIN32
#define NOVTABLE__ __declspec(novtable)
#else
#define NOVTABLE__
#endif
#endif

namespace utils {
namespace async {
struct Any {

   private:

    struct NOVTABLE__ interface__ {
        virtual const void* raw__() const noexcept = 0;
        virtual const std::type_info& type__() const noexcept = 0;
        virtual interface__* move__(void* __storage_box) = 0;

        virtual ~interface__() = default;
    };

    template<class T__>
    struct implements__ : interface__ {
        T__ t_holder_;

        template<class V__>
        implements__(V__&& args)
            :t_holder_(std::forward<V__>(args)){}

        const void* raw__() const noexcept override {
            return static_cast<const void*>(std::addressof(t_holder_));
        }

        const std::type_info& type__() const noexcept override {
            return typeid(T__);
        }

        interface__* move__(void* __storage_box) override {
           using gen_type = implements__<T__>;
           if constexpr (sizeof(gen_type) <= sizeof(void*)*2&&
                         alignof(gen_type) <= alignof(std::max_align_t)&&
                         std::is_nothrow_move_constructible<T__>::value) {
               return new(__storage_box) implements__<T__>(std::move(t_holder_));
           }
           else {
               return nullptr;
           }
        }

    };

    union {
        char __storage_box[sizeof(void*)*(1+(2))]{0};
        std::max_align_t __align_of;
        struct {
            void* __place_holder[2];
            interface__* iface;
        };
    };

    template<class T__>
    void new___(T__&& v) {
        interface__* p = nullptr;
        using decay_T__ = std::decay_t<T__>;
        using gen_type= implements__<decay_T__>;
        if constexpr (sizeof(gen_type) <= sizeof(void*)*2&&
                      alignof(gen_type) <= alignof(std::max_align_t)&&
                      std::is_nothrow_move_constructible<decay_T__>::value) {
            p = new (__storage_box) gen_type(std::forward<T__>(v));
        }
        else {
            p = new gen_type(std::forward<T__>(v));
        }
        iface = p;
    }

    bool is_local___() const {
        return static_cast<const void*>(__storage_box)==static_cast<const void*>(iface);
    }

    void delete___() {
        if(!iface)return;
        if(!is_local___()) {
            delete iface;
        }
        else {
            iface->~interface__();
        }
        iface=nullptr;
    }

   public:
    constexpr Any(){}

    constexpr Any(std::nullptr_t){}

    template <class T__>
    Any(T__&& t) {
        static_assert(!std::is_same<std::decay_t<T__>,Any>::value,"can't accept same type");
        new___(std::forward<T__>(t));
    }

    Any(Any&& in) noexcept {
        // reference implementation: MSVC std::function
        if (in.is_local___()) {
            iface = in.iface->move__(__storage_box);
            in.delete___();
        }
        else {
            iface = in.iface;
            in.iface = nullptr;
        }
    }

    Any& operator=(Any&& in) noexcept {
        if(this==std::addressof(in))return *this;
        delete___();
        // reference implementation: MSVC std::function
        if (in.is_local___()) {
            iface = in.iface->move__(__storage_box);
            in.delete___();
        }
        else {
            iface = in.iface;
            in.iface = nullptr;
        }
        return *this;
    }

    explicit operator bool() const noexcept {
        return iface != nullptr;
    }

    bool operator==(std::nullptr_t) const noexcept {
        return iface == nullptr;
    }
    
    ~Any() {
        delete___();
    }

    template<class T__>
    const T__* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T__)) {
            return nullptr;
        }
        return static_cast<const T__*>(iface->raw__());
    }

    template<class T__>
    T__* type_assert() {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T__)) {
            return nullptr;
        }
        return static_cast<T__*>(const_cast<void*>(iface->raw__()));
    }

    const void* unsafe_cast() const {
        if(!iface){
            return nullptr;
        }
        return iface->raw__();
    }

    void* unsafe_cast() {
        if(!iface){
            return nullptr;
        }
        return const_cast<void*>(iface->raw__());
    }

    Any(const Any&) = delete;

    Any& operator=(const Any&) = delete;

    Any(Any&) = delete;

    Any& operator=(Any&) = delete;

};

struct Event {

   private:

    struct NOVTABLE__ interface__ {
        virtual const void* raw__() const noexcept = 0;
        virtual const std::type_info& type__() const noexcept = 0;
        virtual size_t priority() = 0;
        virtual void set_priority(size_t p) = 0;
        virtual interface__* move__(void* __storage_box) = 0;

        virtual ~interface__() = default;
    };

    template<class T__>
    struct implements__ : interface__ {
        T__ t_holder_;

        template<class V__>
        implements__(V__&& args)
            :t_holder_(std::forward<V__>(args)){}

        const void* raw__() const noexcept override {
            return static_cast<const void*>(std::addressof(t_holder_));
        }

        const std::type_info& type__() const noexcept override {
            return typeid(T__);
        }

        size_t priority() override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return size_t{};
            }
            return t_ptr_->priority();
        }

        void set_priority(size_t p) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return (void)0;
            }
            t_ptr_->set_priority(p);
        }

        interface__* move__(void* __storage_box) override {
           using gen_type = implements__<T__>;
           if constexpr (sizeof(gen_type) <= sizeof(void*)*3&&
                         alignof(gen_type) <= alignof(std::max_align_t)&&
                         std::is_nothrow_move_constructible<T__>::value) {
               return new(__storage_box) implements__<T__>(std::move(t_holder_));
           }
           else {
               return nullptr;
           }
        }

    };

    union {
        char __storage_box[sizeof(void*)*(1+(3))]{0};
        std::max_align_t __align_of;
        struct {
            void* __place_holder[3];
            interface__* iface;
        };
    };

    template<class T__>
    void new___(T__&& v) {
        interface__* p = nullptr;
        using decay_T__ = std::decay_t<T__>;
        using gen_type= implements__<decay_T__>;
        if constexpr (sizeof(gen_type) <= sizeof(void*)*3&&
                      alignof(gen_type) <= alignof(std::max_align_t)&&
                      std::is_nothrow_move_constructible<decay_T__>::value) {
            p = new (__storage_box) gen_type(std::forward<T__>(v));
        }
        else {
            p = new gen_type(std::forward<T__>(v));
        }
        iface = p;
    }

    bool is_local___() const {
        return static_cast<const void*>(__storage_box)==static_cast<const void*>(iface);
    }

    void delete___() {
        if(!iface)return;
        if(!is_local___()) {
            delete iface;
        }
        else {
            iface->~interface__();
        }
        iface=nullptr;
    }

   public:
    constexpr Event(){}

    constexpr Event(std::nullptr_t){}

    template <class T__>
    Event(T__&& t) {
        static_assert(!std::is_same<std::decay_t<T__>,Event>::value,"can't accept same type");
        new___(std::forward<T__>(t));
    }

    Event(Event&& in) noexcept {
        // reference implementation: MSVC std::function
        if (in.is_local___()) {
            iface = in.iface->move__(__storage_box);
            in.delete___();
        }
        else {
            iface = in.iface;
            in.iface = nullptr;
        }
    }

    Event& operator=(Event&& in) noexcept {
        if(this==std::addressof(in))return *this;
        delete___();
        // reference implementation: MSVC std::function
        if (in.is_local___()) {
            iface = in.iface->move__(__storage_box);
            in.delete___();
        }
        else {
            iface = in.iface;
            in.iface = nullptr;
        }
        return *this;
    }

    explicit operator bool() const noexcept {
        return iface != nullptr;
    }

    bool operator==(std::nullptr_t) const noexcept {
        return iface == nullptr;
    }
    
    ~Event() {
        delete___();
    }

    template<class T__>
    const T__* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T__)) {
            return nullptr;
        }
        return static_cast<const T__*>(iface->raw__());
    }

    template<class T__>
    T__* type_assert() {
        if (!iface) {
            return nullptr;
        }
        if (iface->type__()!=typeid(T__)) {
            return nullptr;
        }
        return static_cast<T__*>(const_cast<void*>(iface->raw__()));
    }

    const void* unsafe_cast() const {
        if(!iface){
            return nullptr;
        }
        return iface->raw__();
    }

    void* unsafe_cast() {
        if(!iface){
            return nullptr;
        }
        return const_cast<void*>(iface->raw__());
    }

    size_t priority() {
        return iface?iface->priority():size_t{};
    }

    void set_priority(size_t p) {
        return iface?iface->set_priority(p):(void)0;
    }

    Event(const Event&) = delete;

    Event& operator=(const Event&) = delete;

    Event(Event&) = delete;

    Event& operator=(Event&) = delete;

};

template<typename Ctx>
struct Task {

   private:

    struct NOVTABLE__ interface__ {
        virtual void operator()(Ctx& ctx) = 0;
        virtual const void* raw__(const std::type_info&) const noexcept = 0;
        virtual interface__* move__(void* __storage_box) = 0;

        virtual ~interface__() = default;
    };

    template<class T__>
    struct implements__ : interface__ {
        T__ t_holder_;

        template<class V__>
        implements__(V__&& args)
            :t_holder_(std::forward<V__>(args)){}

        void operator()(Ctx& ctx) override {
            auto t_ptr_ = utils::helper::deref(this->t_holder_);
            if (!t_ptr_) {
                return (void)0;
            }
            (*t_ptr_)(ctx);
        }

        const void* raw__(const std::type_info&info__) const noexcept override {
            if (info__!=typeid(T__)) {
                return nullptr;
            }
            return static_cast<const void*>(std::addressof(t_holder_));
        }

        interface__* move__(void* __storage_box) override {
           using gen_type = implements__<T__>;
           if constexpr (sizeof(gen_type) <= sizeof(void*)*2&&
                         alignof(gen_type) <= alignof(std::max_align_t)&&
                         std::is_nothrow_move_constructible<T__>::value) {
               return new(__storage_box) implements__<T__>(std::move(t_holder_));
           }
           else {
               return nullptr;
           }
        }

    };

    union {
        char __storage_box[sizeof(void*)*(1+(2))]{0};
        std::max_align_t __align_of;
        struct {
            void* __place_holder[2];
            interface__* iface;
        };
    };

    template<class T__>
    void new___(T__&& v) {
        interface__* p = nullptr;
        using decay_T__ = std::decay_t<T__>;
        using gen_type= implements__<decay_T__>;
        if constexpr (sizeof(gen_type) <= sizeof(void*)*2&&
                      alignof(gen_type) <= alignof(std::max_align_t)&&
                      std::is_nothrow_move_constructible<decay_T__>::value) {
            p = new (__storage_box) gen_type(std::forward<T__>(v));
        }
        else {
            p = new gen_type(std::forward<T__>(v));
        }
        iface = p;
    }

    bool is_local___() const {
        return static_cast<const void*>(__storage_box)==static_cast<const void*>(iface);
    }

    void delete___() {
        if(!iface)return;
        if(!is_local___()) {
            delete iface;
        }
        else {
            iface->~interface__();
        }
        iface=nullptr;
    }

   public:
    constexpr Task(){}

    constexpr Task(std::nullptr_t){}

    template <class T__>
    Task(T__&& t) {
        static_assert(!std::is_same<std::decay_t<T__>,Task>::value,"can't accept same type");
        if(!utils::helper::deref(t)){
            return;
        }
        new___(std::forward<T__>(t));
    }

    Task(Task&& in) noexcept {
        // reference implementation: MSVC std::function
        if (in.is_local___()) {
            iface = in.iface->move__(__storage_box);
            in.delete___();
        }
        else {
            iface = in.iface;
            in.iface = nullptr;
        }
    }

    Task& operator=(Task&& in) noexcept {
        if(this==std::addressof(in))return *this;
        delete___();
        // reference implementation: MSVC std::function
        if (in.is_local___()) {
            iface = in.iface->move__(__storage_box);
            in.delete___();
        }
        else {
            iface = in.iface;
            in.iface = nullptr;
        }
        return *this;
    }

    explicit operator bool() const noexcept {
        return iface != nullptr;
    }

    bool operator==(std::nullptr_t) const noexcept {
        return iface == nullptr;
    }
    
    ~Task() {
        delete___();
    }

    void operator()(Ctx& ctx) {
        return iface?iface->operator()(ctx):(void)0;
    }

    template<class T__>
    const T__* type_assert() const {
        if (!iface) {
            return nullptr;
        }
        return static_cast<const T__*>(iface->raw__(typeid(T__)));
    }

    template<class T__>
    T__* type_assert() {
        if (!iface) {
            return nullptr;
        }
        return static_cast<T__*>(const_cast<void*>(iface->raw__(typeid(T__))));
    }

    Task(const Task&) = delete;

    Task& operator=(const Task&) = delete;

    Task(Task&) = delete;

    Task& operator=(Task&) = delete;

};

} // namespace async
} // namespace utils
